<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Android</title>
      <link href="/2020/08/19/Activity%E5%88%9D%E6%8E%A2/"/>
      <url>/2020/08/19/Activity%E5%88%9D%E6%8E%A2/</url>
      
        <content type="html"><![CDATA[<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h2><p> Android其实是通过任务(task)来管理Activity的，每一个task都是一组存放在栈中的Activity集合，这个栈也称为返回栈(back stack),栈是一种后进先出的数据结构。在默认情况下，我们启动了一个新的Activity，他就会在返回栈中入栈，并处于栈顶的位置。每当我们启动新的Activity时，都会在返回栈中入栈，且位于栈顶。而当我们back或者finish销毁Activity时，处于当前返回栈栈顶的Activity将会出栈，前一个入栈的Activity将会处于栈顶的位置。系统总是会显示处于栈顶的Activity给用户。</p><hr><h2 id="Activity的状态"><a href="#Activity的状态" class="headerlink" title="Activity的状态"></a>Activity的状态</h2><ol><li><p>运行状态</p><p>当Activity处于栈顶，且为可见状态时，即为运行状态。系统不愿意回收可见状态的Activity，因为这会给用户带来极差的体验。</p></li><li><p>暂停状态</p><p>当Activity不处在栈顶，且不完全为可见状态时，即为暂停状态。<code>例如对话框形式的Activity即只占用了部分区域的Activity</code> 系统也不愿意回收这种Activity，只有在内存极低的情况下系统才会去考虑回收这种Activity</p></li><li><p>停止状态</p><p>当Activity不处于栈顶，且完全不可见时，即为停止状态，系统仍然会为这种Activity保存相应的状态和成员变量，但这并不是完全可靠的，当其他地方需要内存时，处于停止状态的Activity有可能被系统回收。</p></li><li><p>销毁状态</p><p>一个Activity从栈中移除后就变成了销毁状态。系统倾向于回收这种状态的Activity，以保存系统内存的充足。</p></li></ol><p>未完待续…</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2020/08/18/Spring%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/18/Spring%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-QBFyaJxn" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h1 id="爬坑Spring"><a href="#爬坑Spring" class="headerlink" title="爬坑Spring"></a>爬坑Spring</h1><p>[TOC]</p><h2 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h2><h3 id="1-1-官网"><a href="#1-1-官网" class="headerlink" title="1.1 官网"></a>1.1 官网</h3><p><a href="https://spring.io/">spring官网</a></p><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html">spring文档</a></p><p><a href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference">spring中文文档</a></p><h3 id="1-2-理念"><a href="#1-2-理念" class="headerlink" title="1.2 理念"></a>1.2 理念</h3><p>使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架</p><h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a>1.3 优点</h3><ul><li><p>Spring是一个开源的免费的框架(容器)</p></li><li><p>Spring是一个轻量级的、非侵入式的框架</p></li><li><p>控制权反转 IOC，面向切面编程 AOP</p></li><li><p>支持事务的处理，对框架整合的支持</p></li></ul><h3 id="1-4-组成"><a href="#1-4-组成" class="headerlink" title="1.4 组成"></a>1.4 组成</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151520.png"></p><h3 id="1-5-拓展"><a href="#1-5-拓展" class="headerlink" title="1.5 拓展"></a>1.5 拓展</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151531.png"></p><ul><li><p>Spring boot</p><ul><li>一个快速开发的脚手架。</li><li>基于Spring Boot可以快速开发单个微服务。</li><li>约定大于配置。</li></ul></li><li><p>Spring Cloud</p><ul><li>基于Spring Boot实现的。</li></ul></li></ul><p>== 现在大部分公司都在使用Spring Boot进行快速开发，学习Spring Boot的前提，需要完全掌握Spring 及 SpringMVC == </p><p><strong>Spring弊端：发展太久后违背了最初理念，配置十分繁琐，直至Spring Boot的出现</strong></p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="2-1-IOC的推导"><a href="#2-1-IOC的推导" class="headerlink" title="2.1 IOC的推导"></a>2.1 IOC的推导</h3><h4 id="2-1-1-初识控制权反转"><a href="#2-1-1-初识控制权反转" class="headerlink" title="2.1.1 初识控制权反转"></a>2.1.1 初识控制权反转</h4><ol><li>UserDao 接口</li><li>UserDaoImpl 接口实现类</li><li>UserService 业务接口</li><li>UserServiceImpl 业务实现类</li></ol><h5 id="IOC原型之静态生成对象–控制权掌握在程序员手中"><a href="#IOC原型之静态生成对象–控制权掌握在程序员手中" class="headerlink" title="IOC原型之静态生成对象–控制权掌握在程序员手中"></a>IOC原型之静态生成对象–控制权掌握在程序员手中</h5><pre class="language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService&#123;    private UserDao userDao &#x3D;new UserDaoMysqlImpl();    public void getUser() &#123;        userDao.getUser();    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;用户调用业务层，dao无需接触        UserServiceImpl userService &#x3D; new UserServiceImpl();        userService.getUser();    &#125;&#125;</code></pre><p>通过new的方式，在service层静态的，固定的给出了业务实现，用户无法进行控制。</p><hr><h5 id="IOC原型之动态生成对象–控制权掌握在用户手中"><a href="#IOC原型之动态生成对象–控制权掌握在用户手中" class="headerlink" title="IOC原型之动态生成对象–控制权掌握在用户手中"></a>IOC原型之动态生成对象–控制权掌握在用户手中</h5><pre class="language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService&#123;    private UserDao userDao;    &#x2F;&#x2F;使用set进行注入    public void setUserDao(UserDao userDao) &#123;        this.userDao &#x3D; userDao;    &#125;    public void getUser() &#123;        userDao.getUser();    &#125;&#125;</code></pre><p>通过set方法注入，使得service层动态加载业务，具体业务的种类的选择权转移到了用户手中。</p><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;用户调用业务层，dao无需接触        UserServiceImpl userService &#x3D; new UserServiceImpl();        userService.setUserDao(new UserDaoMysqlImpl());        userService.getUser();    &#125;&#125;</code></pre><ul><li><p>之前，程序是主动创建对象，控制权在程序员手中。</p></li><li><p>使用set注入之后，程序不再具有主动性，控制权转移到了用户手中。</p><h5 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h5></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151544.png"></p><ul><li>过去，如图1，我们希望在四个模块中间有一个中间件进行联系，那么我们只需要调用中间件即可访问其他模块</li><li>于是乎IOC容器诞生了，由IOC容器连接模块，模块间不再具有强耦合性，用户决定调用的方向。</li></ul><p><code>总结：控制权反转(IOC)，是一种使得程序从主动改变转换为被动接收，将控制权由开发人员手中转移到用户手中的设计思想而非具体实现方法，DI(依赖注入)是实现IOC的一种方法</code></p><p><code>控制权反转是一种通过描述(XML或注解)并通过第三方去生产或获取特定对象的方式。在Spring中实现控制权反转的是IOC容器，其实现的方法为依赖注入(Dependency Injection,DI)</code></p><hr><h4 id="2-1-2-第一个Spring程序"><a href="#2-1-2-第一个Spring程序" class="headerlink" title="2.1.2  第一个Spring程序"></a>2.1.2  第一个Spring程序</h4><h5 id="配置文件的编写"><a href="#配置文件的编写" class="headerlink" title="配置文件的编写"></a>配置文件的编写</h5><h6 id="使用XML"><a href="#使用XML" class="headerlink" title="使用XML"></a>使用XML</h6><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;    &lt;bean id&#x3D;&quot;Mysql&quot; class&#x3D;&quot;com.chengzzz.dao.UserDaoMysqlImpl&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;oracle&quot; class&#x3D;&quot;com.chengzzz.dao.UserDaoOracleImpl&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.chengzzz.dao.UserDaoImpl&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;userservices&quot; class&#x3D;&quot;com.chengzzz.service.UserServiceImpl&quot;&gt;        &lt;!--        ref:引用容器中创建好的对象         value:具体的值        --&gt;        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;user&quot;&gt;&lt;&#x2F;property&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><p><code>以上Bean类通过在XML中声明后，即可通过ApplicationContext ApplicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;)读取到配置文件，从而使得IOC容器实现控制权反转</code></p><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;        ApplicationContext ApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        UserService userservices &#x3D; ApplicationContext.getBean(&quot;userservices&quot;,UserServiceImpl.class);        userservices.getUser();    &#125;&#125;</code></pre><p><code>以上即为Spring通过xml 实现控制权反转后产生的实体类对象，通过getBean方法获取并得以使用</code></p><h6 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h6><h6 id="使用纯java代码"><a href="#使用纯java代码" class="headerlink" title="使用纯java代码"></a>使用纯java代码</h6><h5 id="IOC对象的创建"><a href="#IOC对象的创建" class="headerlink" title="IOC对象的创建"></a>IOC对象的创建</h5><h6 id="IOC创建对象的方式"><a href="#IOC创建对象的方式" class="headerlink" title="IOC创建对象的方式"></a>IOC创建对象的方式</h6><ol><li><p>无参构造器创建对象，默认方法</p><pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot;&gt;&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</code></pre></li></ol><ol start="2"><li><p>有参构造创建对象</p><p>下标注入</p><pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot;&gt; &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;constructor-arg&gt;&lt;&#x2F;bean&gt;</code></pre></li></ol><p>   类型注入</p>   <pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot;&gt;    &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;constructor-arg&gt;&lt;&#x2F;bean&gt;</code></pre><p>   参数名注入</p>   <pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot;&gt;    &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;constructor-arg&gt;&lt;&#x2F;bean&gt;</code></pre><hr><h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><h3 id="3-1-alisas-别名"><a href="#3-1-alisas-别名" class="headerlink" title="3.1 alisas(别名)"></a>3.1 alisas(别名)</h3><pre class="language-java" data-language="java"><code class="language-java">&lt;alias name&#x3D;&quot;hello&quot; alias&#x3D;&quot;hello2&quot;&gt;&lt;&#x2F;alias&gt;</code></pre><p>没什么卵用</p><pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot; name&#x3D;&quot;hello2,hello1&quot;&gt;    &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;constructor-arg&gt;&lt;&#x2F;bean&gt;</code></pre><p>在bean的注册中可以使用name来写入别名</p><hr><h3 id="3-2-Import"><a href="#3-2-Import" class="headerlink" title="3.2 Import"></a>3.2 Import</h3><p>导入配置文件，团队开发中，含有多个配置文件时可以使用import将所有的配置文件合并为一个。</p><pre class="language-java" data-language="java"><code class="language-java">&lt;import resource&#x3D;&quot;beans1.xml&quot;&gt;&lt;&#x2F;import&gt;&lt;import resource&#x3D;&quot;beans2.xml&quot;&gt;&lt;&#x2F;import&gt;&lt;import resource&#x3D;&quot;beans3.xml&quot;&gt;&lt;&#x2F;import&gt;</code></pre><p><code>注意重名时，后导入的会覆盖前导入的</code></p><hr><h2 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI(依赖注入)"></a>DI(依赖注入)</h2><h3 id="4-1-构造器注入"><a href="#4-1-构造器注入" class="headerlink" title="4.1 构造器注入"></a>4.1 构造器注入</h3><p>参考上文  <strong>IOC创建对象的方式</strong></p><hr><h3 id="4-2-Set方法注入"><a href="#4-2-Set方法注入" class="headerlink" title="4.2 Set方法注入"></a><strong>4.2 Set方法注入</strong></h3><p><strong>Set方法注入【重点</strong>】</p><ul><li>Set注入是依赖注入的本质，依赖注入的本质是Set注入<ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象中的所有属性，都由容器来注入</li></ul></li></ul><p>测试环境</p><p>Student类</p><pre class="language-java" data-language="java"><code class="language-java">public class Student &#123;    private String name;    private Address address;    private String[] books;    private List&lt;String&gt; hobbys;    private Map&lt;String,String&gt; card;    private Set&lt;String&gt; games;    private String wife;    private Properties info;    &#x2F;*get set tosting方法省略*&#x2F;&#125;</code></pre><p>Address类</p><pre class="language-java" data-language="java"><code class="language-java">public class Address &#123;    private String address;&#x2F;*get set tosting方法省略*&#x2F;&#125;</code></pre><p>beans.xml</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.chengzzz.pojo.Student&quot;&gt;       &lt;!--普通值注入--&gt;       &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;property&gt;   &lt;&#x2F;bean&gt;   &lt;bean id&#x3D;&quot;address&quot; class&#x3D;&quot;com.chengzzz.pojo.Address&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><p>完整注入xml</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.chengzzz.pojo.Student&quot;&gt;    &lt;!--1.普通值注入 value--&gt;    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;property&gt;    &lt;!--2.bean注入 ref--&gt;    &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;address&quot;&gt;&lt;&#x2F;property&gt;    &lt;!--3.数组注入 ref--&gt;    &lt;property name&#x3D;&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;红楼梦&lt;&#x2F;value&gt;            &lt;value&gt;西游记&lt;&#x2F;value&gt;            &lt;value&gt;三国演义&lt;&#x2F;value&gt;            &lt;value&gt;水浒传&lt;&#x2F;value&gt;        &lt;&#x2F;array&gt;    &lt;&#x2F;property&gt;    &lt;!--4.list注入--&gt;    &lt;property name&#x3D;&quot;hobbys&quot;&gt;        &lt;list&gt;            &lt;value&gt;打游戏&lt;&#x2F;value&gt;            &lt;value&gt;听歌&lt;&#x2F;value&gt;            &lt;value&gt;睡觉&lt;&#x2F;value&gt;        &lt;&#x2F;list&gt;    &lt;&#x2F;property&gt;    &lt;!--5.map注入--&gt;    &lt;property name&#x3D;&quot;card&quot;&gt;        &lt;map&gt;            &lt;entry key&#x3D;&quot;身份证&quot; value&#x3D;&quot;111&quot;&gt;&lt;&#x2F;entry&gt;            &lt;entry key&#x3D;&quot;银行卡&quot; value&#x3D;&quot;222&quot;&gt;&lt;&#x2F;entry&gt;            &lt;entry key&#x3D;&quot;校园卡&quot; value&#x3D;&quot;333&quot;&gt;&lt;&#x2F;entry&gt;        &lt;&#x2F;map&gt;    &lt;&#x2F;property&gt;    &lt;!--6.set注入--&gt;    &lt;property name&#x3D;&quot;games&quot;&gt;        &lt;set&gt;            &lt;value&gt;lol&lt;&#x2F;value&gt;            &lt;value&gt;wow&lt;&#x2F;value&gt;        &lt;&#x2F;set&gt;    &lt;&#x2F;property&gt;    &lt;!--7.null注入--&gt;    &lt;property name&#x3D;&quot;wife&quot;&gt;        &lt;null&gt;&lt;&#x2F;null&gt;    &lt;!--8.Properties注入--&gt;    &lt;&#x2F;property&gt;    &lt;property name&#x3D;&quot;info&quot;&gt;        &lt;props&gt;            &lt;prop key&#x3D;&quot;drive&quot;&gt;12333&lt;&#x2F;prop&gt;            &lt;prop key&#x3D;&quot;sex&quot;&gt;女&lt;&#x2F;prop&gt;        &lt;&#x2F;props&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;address&quot; class&#x3D;&quot;com.chengzzz.pojo.Address&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="4-3-拓展方式注入"><a href="#4-3-拓展方式注入" class="headerlink" title="4.3 拓展方式注入"></a>4.3 拓展方式注入</h3><ul><li><p>P命名空间注入(p=property即属性注入)</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;     xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;      xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;     xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;  &lt;!--p命名空间注入--&gt;  &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.chengzzz.pojo.User&quot; p:name&#x3D;&quot;小橙子&quot; p:age&#x3D;&quot;18&quot;&#x2F;&gt;  &lt;&#x2F;beans&gt;</code></pre></li></ul><ul><li><p>C命名空间注入(c=constructor-arg即构造器注入)</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;     xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;        xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;     xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;  &lt;!--c命名空间注入--&gt;  &lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;com.chengzzz.pojo.User&quot; c:name&#x3D;&quot;小橙子&quot; c:age&#x3D;&quot;19&quot;&#x2F;&gt;  &lt;&#x2F;beans&gt;</code></pre><p><code>注意 p命名空间注入为属性注入即set注入  而set注入必须有无参构造器  c命名空间为有参构造器注入 实体类需重写有参构造方法</code></p><p><code>c命名空间 p命名空间不能直接使用 需要导入依赖</code></p></li></ul><hr><h3 id="4-4-Bean的作用域"><a href="#4-4-Bean的作用域" class="headerlink" title="4.4 Bean的作用域"></a>4.4 Bean的作用域</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151603.png"></p><ol><li><p>单例模式【Spring默认模式】</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;com.chengzzz.pojo.User&quot; c:name&#x3D;&quot;小橙子&quot; c:age&#x3D;&quot;19&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt;</code></pre></li></ol><ol start="2"><li><p>原型模式</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;com.chengzzz.pojo.User&quot; c:name&#x3D;&quot;小橙子&quot; c:age&#x3D;&quot;19&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;</code></pre></li><li><p>其余的request、sesstion、application只在web开发中使用到</p></li></ol><hr><h2 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h2><ul><li>自动装配是Spring满足bean依赖的一种方式。</li><li>Spring会在上下文中自动寻找，并自动给bean装配属性</li></ul><p>Spring中装配方式有三种</p><ol><li>在xml中显式地配置</li><li>在java中显式地配置</li><li><strong>隐式的自动装配bean 【重要】</strong></li></ol><h3 id="5-1测试"><a href="#5-1测试" class="headerlink" title="5.1测试"></a>5.1测试</h3><p>测试类</p><pre class="language-java" data-language="java"><code class="language-java">public class Cat &#123;    public void shout()&#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class Dog &#123;    public void shout()&#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class People &#123;    private Cat cat;    private Dog dog;    private String name;    public Cat getCat() &#123;        return cat;    &#125;    public void setCat(Cat cat) &#123;        this.cat &#x3D; cat;    &#125;    public Dog getDog() &#123;        return dog;    &#125;    public void setDog(Dog dog) &#123;        this.dog &#x3D; dog;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;&#125;</code></pre><p>配置文件</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;www.chengzzz.pojo.Cat&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;www.chengzzz.pojo.Dog&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;people&quot; class&#x3D;&quot;www.chengzzz.pojo.People&quot;&gt;    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;xxx&quot;&gt;    &lt;&#x2F;property&gt;    &lt;property name&#x3D;&quot;cat&quot; ref&#x3D;&quot;cat&quot;&gt;    &lt;&#x2F;property&gt;    &lt;property name&#x3D;&quot;dog&quot; ref&#x3D;&quot;dog&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</code></pre><hr><h3 id="5-2-自动装配的方式"><a href="#5-2-自动装配的方式" class="headerlink" title="5.2 自动装配的方式"></a>5.2 自动装配的方式</h3><ol><li><p>byName(在容器上下文中查找和自己对象set方法后面的值对应的beanid) 名字必须唯一</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;people&quot; class&#x3D;&quot;www.chengzzz.pojo.People&quot; autowire&#x3D;&quot;byName&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;xxx&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre></li></ol><ol start="2"><li><p>byType(在容器上下文中查找和自己对象属性类型相同的bean) </p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;people&quot; class&#x3D;&quot;www.chengzzz.pojo.People&quot; autowire&#x3D;&quot;byType&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;xxx&quot;&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</code></pre></li></ol><p>   <code>小节</code></p><ul><li>byname的时候。需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法值一致。</li><li>bytype的时候。需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</li></ul><hr><h3 id="5-3-使用注解实现自动装配"><a href="#5-3-使用注解实现自动装配" class="headerlink" title="5.3 使用注解实现自动装配"></a>5.3 使用注解实现自动装配</h3><p>JDK从1.5开始支持的注解，Spring从2.5就开始支持注解</p><p><code>使用注解注意点</code></p><ol><li><p>导入约束</p><p>&lt;!–hexoPostRenderEscape:<pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;<a href="http://www.springframework.org&/#x2F;schema&#x2F;beans">www.springframework.org&#x2F;schema&#x2F;beans</a>&quot;</p><pre><code>xmlns:xsi&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.w3.org&amp;#x2F;2001&amp;#x2F;XMLSchema-instance&amp;quot;xmlns:context&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;context&amp;quot;xsi:schemaLocation&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;beans http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;beans&amp;#x2F;spring-beans.xsd http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;context http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;beans&amp;#x2F;spring-context.xsd&amp;quot;&amp;gt;</code></pre></li></ol><p>&lt;&#x2F;beans&gt;</code></pre>:hexoPostRenderEscape–&gt;</p><ol start="2"><li>开启注解支持</li></ol><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;context:annotation-config&#x2F;&gt;</code></pre><p>在属性上直接使用也可以在set方法上使用，实体类可以没有set方法前提是符合byType</p><pre class="language-java" data-language="java"><code class="language-java">@Autowired@Qualifier(value &#x3D; &quot;cat&quot;)  &#x2F;&#x2F;此注解可指定自动装配name为cat的bean</code></pre><p><code>Tips</code></p><pre class="language-xml" data-language="xml"><code class="language-xml">@Nullable &#x2F;&#x2F;字段标记了这个注解 说明这个字段可以为null@Autowired(required&#x3D;false) &#x2F;&#x2F;表示这个对象可以为null@Resource &#x2F;&#x2F;jdk的注解，亦可指定@Resource(name&#x3D;&quot;cat&quot;)  此注解在jdk11中被移除</code></pre><p><code>@Resource和@Autowired的区别</code></p><ul><li>都是用来自动装配的，都可以放在属性字段上</li><li>@AutoWired默认通过byType实现，必须要求其存在，否则空指针</li><li>@Resource默认通过byName方式实现，如果找不到名字则通过byType实现，如果找不到则报错。</li></ul><hr><h2 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><p>在Spring4之后 要使用注解开发，必须导入aop的包</p><p>需要导入context的约束，开启注解支持</p><p><code>注解</code></p><pre class="language-xml" data-language="xml"><code class="language-xml">@Component &#x2F;&#x2F;声明此类为自动装配的组件，配合自动扫描包实现自动装配@Value(&quot;小橙子&quot;) &#x2F;&#x2F;赋值，相当于属性注入中的value@Repository &#x2F;&#x2F;Dao层的标注Component的衍生注解@Service  &#x2F;&#x2F;Service层的标注Component的衍生注解@Controller  &#x2F;&#x2F;Controller层的标注Component的衍生注解@AutoWired &#x2F;&#x2F;自动装配的注解@Scope  &#x2F;&#x2F;模式注解 @Configuration &#x2F;&#x2F;使用java代码实现xml配置@ComponentScan(&quot;com.chengzzz.pojo&quot;)&#x2F;&#x2F;扫描指定的包@Import(bean2.class) &#x2F;&#x2F;导入另外的配置文件@Aspect &#x2F;&#x2F;切面</code></pre><p><code>xml与注解</code></p><ol><li>xml更加万能，维护简单方便</li><li>注解不是自己的类使用不了，维护相对复杂</li></ol><p><code>xml与注解的最佳实现</code></p><ol><li>xml用来管理bean</li><li>注解只负责属性的注入</li><li>我们在使用的过程中只需要注意一个问题：必须让注解生效，就必须开启注解支持。</li></ol><h3 id="6-1-开启注解支持"><a href="#6-1-开启注解支持" class="headerlink" title="6.1 开启注解支持"></a>6.1 开启注解支持</h3><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;!--开启注解支持--&gt; &lt;context:annotation-config&#x2F;&gt; &lt;!--指定需要扫描的包，这个包下的注解会生效--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.chengzzz.pojo&quot;&#x2F;&gt;</code></pre><hr><h3 id="6-2-使用JavaConfig实现配置"><a href="#6-2-使用JavaConfig实现配置" class="headerlink" title="6.2 使用JavaConfig实现配置"></a>6.2 使用JavaConfig实现配置</h3><p>我们现在完全使用java来实现配置</p><p>JavaConfigs Spring的一个子项目，在Spring4之后，他成为了一个核心功能</p><pre class="language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&quot;com.chengzzz.pojo&quot;)@Import(bean2.class)public class MyConfig &#123;    @Bean    public User getUser()&#123;        return new User();    &#125;&#125;</code></pre><p>这种纯Java的配置方式，在SpringBoot中随处可见</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151618.png"></p><p>Spring Aop支持五种类型</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Yet\AppData\Roaming\Typora\typora-user-images\image-20200804132547513.png" alt="image-20200804132547513"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151628.png"></p><p>需要导入依赖包</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.9.5&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre><hr><h3 id="7-1-代理模式"><a href="#7-1-代理模式" class="headerlink" title="7.1 代理模式"></a>7.1 代理模式</h3><p>为什么要学习代理模式？</p><p>因为这就是SpringAop的底层【SpringAop和SpringMVC】</p><p>代理模式的分类：</p><ul><li>静态代理</li><li>动态代理</li></ul><hr><h4 id="7-1-静态代理"><a href="#7-1-静态代理" class="headerlink" title="7.1 静态代理"></a>7.1 静态代理</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151638.png"></p><p>角色分析：</p><ul><li>抽象角色：一般使用接口或者抽象类来解决</li><li>真实角色：被代理的角色</li><li>代理角色：代理真实角色 ，代理真实角色后，我们一般会做一些附加操作</li><li>客户：访问代理对象的角色</li></ul><p>静态代理模式的好处：</p><ul><li>可以使得真实角色的操作更加纯粹，不用去关注一些公共的业务</li><li>公共业务交给代理角色，实现了业务的分工</li><li>公共业务发生扩展的时候方便集中管理</li></ul><p>静态代理模式的缺点：</p><ul><li>一个真实角色就会产生一个代理角色：代码量翻倍，开发效率变低</li></ul><p><code>AOP初识</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151653.png"></p><hr><h4 id="7-2-动态代理"><a href="#7-2-动态代理" class="headerlink" title="7.2 动态代理"></a>7.2 动态代理</h4><ul><li>动态代理和静态代理角色一样</li><li>动态代理的类是动态生成的，不是直接写好的</li><li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理<ul><li>基于接口—-JDK动态代理</li><li>基于类—-cglib</li><li>基于java字节码—-javassist</li></ul></li></ul><p>需要了解两个类 Proxy:代理，InvocationHandler:调用处理程序</p><pre class="language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;重写这个类，实现自动代理public class ProxyInvocationHandler implements InvocationHandler &#123;    &#x2F;&#x2F;被代理的接口    private Object target;    public void setTarget(Object target) &#123;        this.target &#x3D; target;    &#125;    &#x2F;&#x2F;得到代理类    public Object getProxy()&#123;        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);    &#125;    &#x2F;&#x2F;处理代理实例，并返回结果    @Override    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;        &#x2F;&#x2F;动态代理就是利用反射机制实现        Object result &#x3D; method.invoke(target, objects);        return result;    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class User &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;真实角色        App app &#x3D; new App();        &#x2F;&#x2F;代理角色        ProxyInvocationHandler proxyInvocationHandler &#x3D; new ProxyInvocationHandler();        proxyInvocationHandler.setTarget(app);        Download proxy &#x3D; (Download) proxyInvocationHandler.getProxy();        proxy.download();    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public interface Download &#123;    void download();&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class App implements Download&#123;    @Override    public void download() &#123;        System.out.println(&quot;下载&quot;);    &#125;&#125;</code></pre><p>动态代理的优点：</p><ul><li>可以使得真实角色的操作更加纯粹，不用去关注一些公共的业务</li><li>公共业务交给代理角色，实现了业务的分工</li><li>公共业务发生扩展的时候方便集中管理</li><li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可</li></ul><hr><h3 id="7-2-AOP实现方式一"><a href="#7-2-AOP实现方式一" class="headerlink" title="7.2 AOP实现方式一"></a>7.2 AOP实现方式一</h3><p><code>使用Spring的api</code></p><pre class="language-java" data-language="java"><code class="language-java">public class beforlog implements AfterReturningAdvice &#123;    @Override    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;        System.out.println(o1.getClass().getName()+&quot;----&quot;+method.getName());    &#125;&#125;</code></pre><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;services&quot; class&#x3D;&quot;com.chengzzz.services.ServicesImpl&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;log&quot; class&#x3D;&quot;com.chengzzz.log.beforlog&quot;&#x2F;&gt;&lt;aop:config&gt;    &lt;!--注册切点--&gt;    &lt;aop:pointcut id&#x3D;&quot;point&quot; expression&#x3D;&quot;execution(* com.chengzzz.services.ServicesImpl.*(..))&quot;&#x2F;&gt;    &lt;!--注册切入方式--&gt;    &lt;aop:advisor advice-ref&#x3D;&quot;log&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;&lt;&#x2F;aop:config&gt;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;      ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Services services &#x3D; context.getBean(&quot;services&quot;, Services.class);        services.query();    &#125;&#125;</code></pre><p><code>由于动态代理代理的是接口，所以getBean时，需要转换为接口</code></p><hr><h3 id="7-3-AOP实现方式二"><a href="#7-3-AOP实现方式二" class="headerlink" title="7.3 AOP实现方式二"></a>7.3 AOP实现方式二</h3><p><code>使用自定义类实现aop</code></p><pre class="language-java" data-language="java"><code class="language-java">public class DiyPointCut &#123;    public void before()&#123;        System.out.println(&quot;before&quot;);    &#125;    public void after()&#123;        System.out.println(&quot;after&quot;);    &#125;&#125;</code></pre><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;!--切面对象--&gt;&lt;bean id&#x3D;&quot;diypoint&quot; class&#x3D;&quot;com.chengzzz.diy.DiyPointCut&quot;&#x2F;&gt;&lt;aop:config&gt;    &lt;!--自定义切面--&gt;    &lt;aop:aspect ref&#x3D;&quot;diypoint&quot; &gt;        &lt;!--注册切点--&gt;        &lt;aop:pointcut id&#x3D;&quot;point&quot; expression&#x3D;&quot;execution(* com.chengzzz.services.ServicesImpl.*(..))&quot;&#x2F;&gt;        &lt;!--注册通知，通知spring 什么时候（method&#x3D;&quot;before&quot; 即动态代理前后） 对切点执行什么方法（DiyPointCut中的方法）--&gt;        &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;        &lt;aop:after method&#x3D;&quot;after&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;    &lt;&#x2F;aop:aspect&gt;&lt;&#x2F;aop:config&gt;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;      ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Services services &#x3D; context.getBean(&quot;services&quot;, Services.class);        services.query();    &#125;&#125;</code></pre><p><code>由于动态代理代理的是接口，所以getBean时，需要转换为接口</code></p><hr><h3 id="7-4-AOP实现方式三"><a href="#7-4-AOP实现方式三" class="headerlink" title="7.4 AOP实现方式三"></a>7.4 AOP实现方式三</h3><p><code>使用注解方式实现</code></p><pre class="language-java" data-language="java"><code class="language-java">@Aspectpublic class Annolog &#123;    @Before(&quot;execution(* com.chengzzz.services.ServicesImpl.*(..))&quot;)    public void before()&#123;        System.out.println(&quot;注解前置增强&quot;);    &#125;&#125;</code></pre><pre class="language-none"><code class="language-none">&lt;!--注入注解切面类--&gt;&lt;bean id&#x3D;&quot;annolog&quot; class&#x3D;&quot;com.chengzzz.log.Annolog&quot;&#x2F;&gt;&lt;!--开启自动代理注解支持--&gt;&lt;!--JDK默认proxy-target-class&#x3D;&quot;false&quot;  若为true 则使用cglib实现   结果无任何区别--&gt;&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;false&quot;&#x2F;&gt;</code></pre><p><code>tips  @Around时，方法中可有参数ProceedingJoinPoint 以此获取部分信息</code></p><pre class="language-java" data-language="java"><code class="language-java">@Around(&quot;execution(* com.chengzzz.services.ServicesImpl.*(..))&quot;)public void around(ProceedingJoinPoint joinPoint) throws Throwable&#123;    System.out.println(&quot;注解环绕前&quot;+joinPoint.getSignature());   Object proceed &#x3D; joinPoint.proceed();    System.out.println(&quot;注解环绕后&quot;+proceed);&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;      ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Services services &#x3D; context.getBean(&quot;services&quot;, Services.class);        services.query();    &#125;&#125;</code></pre><p><code>由于动态代理代理的是接口，所以getBean时，需要转换为接口</code></p><hr><h2 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h2><ol><li><p>导入jar包</p><ul><li>junit</li><li>mybatis</li><li>mysql</li><li>spring</li><li>aop</li><li>mybatis-spring</li></ul><p>&lt;!–hexoPostRenderEscape:<pre class="language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;<br> &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;junit&#x2F;junit --&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;junit&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;&amp;#x2F;version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;&amp;#x2F;scope&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;<br> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java –&gt;<br> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;mysql&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.21&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;</p><p> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.5&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;</p><p> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-webmvc –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.springframework&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.7.RELEASE&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;<br> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-jdbc –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.springframework&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.7.RELEASE&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;<br> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.5&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;</p><p> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis-spring –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.5&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;</p></li></ol><p>&lt;&#x2F;dependencies&gt;</code></pre>:hexoPostRenderEscape–&gt;</p><ol start="2"><li>编写配置文件</li></ol><ol start="3"><li>测试</li></ol><h3 id="8-1-整合方式一"><a href="#8-1-整合方式一" class="headerlink" title="8.1 整合方式一"></a>8.1 整合方式一</h3><p>mybatis-config</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;    &lt;bean id&#x3D;&quot;dataSource&quot;          class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;    &gt;        &lt;property name&#x3D;&quot;driverClassName&quot;                  value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;useSSL&#x3D;true&amp;serverTimezone&#x3D;UTC&quot; &#x2F;&gt;        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!-- 创建SqlSessionFactory MyBatis会话工厂对象 --&gt;    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot;  class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;        &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath:com&#x2F;chengzzz&#x2F;mapper&#x2F;*.xml&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;typeAliasesPackage&quot; value&#x3D;&quot;com.chengzzz.pojo&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;bean id&#x3D;&quot;sqlSession&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionTemplate&quot; &gt;        &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><p>beans.xml</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;    &lt;import resource&#x3D;&quot;mybatis-config.xml&quot;&#x2F;&gt;   &lt;bean id&#x3D;&quot;userMapper&quot; class&#x3D;&quot;com.chengzzz.mapper.UserMapperImpl&quot;&gt;   &lt;property name&#x3D;&quot;sqlSession&quot; ref&#x3D;&quot;sqlSession&quot;&#x2F;&gt;   &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><p><code>Tips 注意 若未配置别名，mapper中返回类型需完整路径</code></p><p><code>实现过程</code></p><ol><li>编写数据源配置</li><li>sqlSessionFactory</li><li>sqlSessionTemplate</li><li>需要给接口加实现类</li><li>将实现类注入Spring</li><li>Test   </li></ol><hr><h3 id="8-2-整合方式二"><a href="#8-2-整合方式二" class="headerlink" title="8.2 整合方式二"></a>8.2 整合方式二</h3><p> 在usermapper的实现类中继承SqlSessionDaoSupport</p><p>通过spring的api来获取sqlTemplate</p><pre class="language-java" data-language="java"><code class="language-java">public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper&#123;    @Override    public List&lt;User&gt; selectList() &#123;        return getSqlSession().getMapper(UserMapper.class).selectList();    &#125;&#125;</code></pre><p>同时在spring中注册这个bean时</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;userMapper2&quot; class&#x3D;&quot;com.chengzzz.mapper.UserMapperImpl2&quot;&gt;    &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><p>将sqlSessionFactory注入即可省略sqlSessionTemplate的配置</p><hr><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><h3 id="9-1-事务特点"><a href="#9-1-事务特点" class="headerlink" title="9.1 事务特点"></a>9.1 事务特点</h3><ul><li>将一组业务视为一个业务来实现，要么都成功，要么都失败</li><li>事务在项目开发中，十分重要，涉及到数据的一致性问题，不能马虎</li><li>确保完整性和一致性</li></ul><h3 id="9-2-事务的ACID原则"><a href="#9-2-事务的ACID原则" class="headerlink" title="9.2 事务的ACID原则"></a>9.2 事务的ACID原则</h3><ul><li><p>原子性 确保都失败或都成功。</p></li><li><p>一致性 确保资源状态统一。</p></li><li><p>隔离性</p><ul><li>多个业务操作同一个资源时，防止数据损坏。</li></ul></li><li><p>持久性</p><ul><li>事务一旦提交无论系统发生什么问题，结果都不会再被影响，被持久化地写到存储器中。</li></ul></li></ul><h3 id="9-3-声明式事务的使用"><a href="#9-3-声明式事务的使用" class="headerlink" title="9.3 声明式事务的使用"></a>9.3 声明式事务的使用</h3><ul><li>声明式事务：AOP的应用，非侵入式，横切</li></ul><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;!--配置声明式事务--&gt;    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!--使用AOP实现事务的织入--&gt;    &lt;!--配置事务通知--&gt;    &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;        &lt;!--给哪些方法配置事务--&gt;        &lt;!--事务的7种传播特性--&gt;        &lt;tx:attributes&gt;            &lt;tx:method name&#x3D;&quot;*&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;        &lt;&#x2F;tx:attributes&gt;    &lt;&#x2F;tx:advice&gt;    &lt;!--配置事务的切入--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id&#x3D;&quot;point&quot; expression&#x3D;&quot;execution(* com.chengzzz.mapper.*.*(..))&quot;&#x2F;&gt;        &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;    &lt;&#x2F;aop:config&gt;</code></pre><ul><li>编程式事务：需要在代码中，进行事务的管理</li></ul><p><code>Tips</code></p><p>为什么需要事务？</p><ul><li>如果不配置事务，可能存在数据提交不一致的情况</li><li>如果我们不在Spring中去配置声明式事务，就需要在代码中手动配置事务</li><li>事务在项目的开发中，十分重要涉及到数据的一致性和完整性问题，不容马虎</li></ul><hr><hr><hr><hr>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot 踩坑记录</title>
      <link href="/2020/08/18/Spring%20boot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/08/18/Spring%20boot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-bsnHxPrG" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h1 id="Spring-boot-踩坑记录"><a href="#Spring-boot-踩坑记录" class="headerlink" title="Spring boot 踩坑记录"></a>Spring boot 踩坑记录</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>[TOC]</p><h3 id="Tests-run-1-Failures-0-Errors-1-Skipped-0-Time-elapsed-2-432-s-lt-lt-lt-FAILURE-in-com-ems-web-WebApplicationTests"><a href="#Tests-run-1-Failures-0-Errors-1-Skipped-0-Time-elapsed-2-432-s-lt-lt-lt-FAILURE-in-com-ems-web-WebApplicationTests" class="headerlink" title="Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 2.432 s &lt;&lt;&lt; FAILURE! - in com.ems.web.WebApplicationTests"></a>Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 2.432 s &lt;&lt;&lt; FAILURE! - in com.ems.web.WebApplicationTests</h3><p>解决方案</p><p>在pom.xml中添加</p><pre class="language-none"><code class="language-none">&lt;plugin&gt;    &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;    &lt;configuration&gt;     &lt;skip&gt;true&lt;&#x2F;skip&gt;    &lt;&#x2F;configuration&gt;   &lt;&#x2F;plugin&gt;</code></pre><p>————————————————<br>版权声明：本文为CSDN博主「漫跑的小乌龟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/HHHbetter123/java/article/details/78561642">https://blog.csdn.net/HHHbetter123/java/article/details/78561642</a></p><hr><h3 id="打包后target目录找不到"><a href="#打包后target目录找不到" class="headerlink" title="打包后target目录找不到"></a>打包后target目录找不到</h3><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Yet\AppData\Roaming\Typora\typora-user-images\image-20200628131618898.png" alt="image-20200628131618898"></p><p>yum install -y wget &amp;&amp; wget -O install.sh <a href="http://download.bt.cn/install/install_6.0.sh">http://download.bt.cn/install/install_6.0.sh</a> &amp;&amp; bash install.sh</p><p>Bt-Panel: <a href="http://49.234.35.185:8888/86141926">http://49.234.35.185:8888/86141926</a><br>username: llxyrc7h<br>password: 069c60db<br>If you cannot access the panel,<br>release the following panel port [8888] in the security group<br>若无法访问面板，请检查防火墙/安全组是否有放行面板[8888]端口</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spring boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓蚂蚁森林能量脚本</title>
      <link href="/2020/08/18/%E5%AE%89%E5%8D%93%E8%9A%82%E8%9A%81%E6%A3%AE%E6%9E%97%E8%83%BD%E9%87%8F%E8%84%9A%E6%9C%AC-%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/18/%E5%AE%89%E5%8D%93%E8%9A%82%E8%9A%81%E6%A3%AE%E6%9E%97%E8%83%BD%E9%87%8F%E8%84%9A%E6%9C%AC-%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-KvjcmYLl" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><a href="https://github.com/YYYet/ant-forest-easyclick">开源地址</a></p><h1 id="安卓蚂蚁森林能量脚本-无障碍模式"><a href="#安卓蚂蚁森林能量脚本-无障碍模式" class="headerlink" title="安卓蚂蚁森林能量脚本-无障碍模式"></a>安卓蚂蚁森林能量脚本-无障碍模式</h1><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li><input checked="" disabled="" type="checkbox"> 收自己+偷列表 </li><li><input checked="" disabled="" type="checkbox"> 收别人浇给自己的水</li><li><input checked="" disabled="" type="checkbox"> 帮列表收能量</li></ul><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><ul><li><input checked="" disabled="" type="checkbox"> 定时模式 (手动定时启动脚本)</li><li><input checked="" disabled="" type="checkbox"> 挂机模式 (循环挂机运行脚本)</li><li><input disabled="" type="checkbox"> 自动模式 (自动检测好友能量成熟剩余时间并定时运行脚本)</li></ul><blockquote><p> 以上为已完成的功能</p></blockquote><hr><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>安装软件并给予申请的三个权限</p><p>下拉通知栏观察无障碍模式是否启动</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145614.png"></p><p>如图未启动则打开使用权限页面，点击启动环境</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145630.png"></p><p>悬浮窗权限自行选择是否打开，打开之后重启软件，将会显示日志窗口</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145653.png"></p><p>点击参数设置</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145709.png"></p><p>选择模式</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145721.png"></p><p>选择模式后点击保存参数，再点击启动脚本即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145729.png"></p><blockquote><p>注意</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145742.png"></p><p>定时模式下，填写时间后选择开启定时</p><p>脚本如果长期运行，建议开启屏幕常亮</p></blockquote><hr><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li><p>点击启动环境后无反应或者卡住</p><p>直接清除后台后重新运行软件点击启动环境</p></li><li><p>我开启了无障碍却仍然提示我打开无障碍</p><p>直接清除后台后重新运行软件，然后重新点击启动环境，若没有解决可重启设备</p></li><li><p>脚本部分功能无效</p><p>直接清除后台后重新运行软件点击启动环境</p></li><li><p>无法识别能量罩</p><p>将日志窗口关闭或者拖动到左下角</p></li></ul><hr><h4 id="计划功能"><a href="#计划功能" class="headerlink" title="计划功能"></a>计划功能</h4><ul><li><input disabled="" type="checkbox"> 加入刷步攒能量</li><li><input disabled="" type="checkbox"> 加入批量浇水</li><li><input disabled="" type="checkbox"> 加入运行统计</li><li><input disabled="" type="checkbox"> 加入自动模式</li><li><input disabled="" type="checkbox"> 加入屏幕唤醒及解锁</li></ul><p>​      </p><hr><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>脚本采用EasyClick编写，由于刚接触所以代码质量不高，此项目旨在学习和提高安卓脚本水平</p><p>另外发现github上大佬 SuperMonster003 也在论坛 </p><p>他的帖子<a href="https://www.52pojie.cn/thread-1117218-1-1.html">https://www.52pojie.cn/thread-1117218-1-1.html</a> </p><p>他的主页<a href="https://github.com/SuperMonster003">https://github.com/SuperMonster003</a></p><hr><h4 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h4><p><a href="https://lanzous.com/b0cq9z3ef">https://lanzous.com/b0cq9z3ef</a>  密码:7nh2</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐心健康修改wx zfb qq步数</title>
      <link href="/2020/08/17/%E4%B9%90%E5%BF%83%E5%81%A5%E5%BA%B7/"/>
      <url>/2020/08/17/%E4%B9%90%E5%BF%83%E5%81%A5%E5%BA%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="乐心健康"><a href="#乐心健康" class="headerlink" title="乐心健康"></a>乐心健康</h2>    <div id="aplayer-szQrrIix" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>此程序不调用任何第三方接口，不参与任何非法项目，仅供网络编程学习以及参考。</p><p>自动步数提交已经完成，由于需要上传乐心账号和设备信息等相关信息，乐心账号即为手机号，论坛判为隐私，这里上传无自动提交版本。即不上传任何信息到个人服务器（除了提交相关信息到乐心官方）</p><p><a href="https://github.com/YYYet/Cz-">开源地址</a></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>下载乐某健康APP:</p><p>1.从应用商店或者浏览器下载某心健康App，打开软件并选择手机号登录</p><p><img src= "/img/loading.gif" data-lazy-src="https://txc.gtimg.com/data/130280/2020/0320/1fd9360ff94b7e606fb6607cd5739092.jpeg" alt="1fd9360ff94b7e606fb6607cd5739092.jpeg"></p><p>2.登录之后，点击我的-&gt;设置-&gt;账号与安全-&gt;设置密码(修改密码)，设置你自己记得住的密码</p><p><img src= "/img/loading.gif" data-lazy-src="https://txc.gtimg.com/data/140335/2020/0502/a1c13cfe0dfbf3863cad2838ebfa3009.jpeg" alt="a1c13cfe0dfbf3863cad2838ebfa3009.jpeg"></p><p>3.回到App首页，点击我的-&gt;数据共享，绑定你想同步数据的项目</p><p>注：同步微信运动请按照要求关注【<strong>乐心运动</strong>】公众号。</p><p><img src= "/img/loading.gif" data-lazy-src="https://txc.gtimg.com/data/140335/2020/0507/7bb37ab660a893db887bdddf203122eb.jpeg" alt="7bb37ab660a893db887bdddf203122eb.jpeg"></p><p>4.回到Cz步数助手，依次输入乐心账号（注册乐心的手机号），字母验证码，短信验证码，需要刷的步数，然后点击提交，少数情况需要滑动拼图验证码进行验证。然后步数即可自动同步至你绑定的所有平台。</p><p><img src= "/img/loading.gif" data-lazy-src="https://txc.gtimg.com/data/95845/2020/0612/bbfeeeab7ba95dfabd4bae6e667f4001.jpeg" alt="bbfeeeab7ba95dfabd4bae6e667f4001.jpeg"></p><h2 id="会持续更新吗"><a href="#会持续更新吗" class="headerlink" title="会持续更新吗"></a>会持续更新吗</h2><ol><li><p>我会在空闲时间关注Cz步数助手的走向</p></li><li><p>如果产生不良影响我将第一时间对软件进行处理</p></li></ol><h2 id="软件相关问题"><a href="#软件相关问题" class="headerlink" title="软件相关问题"></a>软件相关问题</h2><h3 id="为什么我的步数不能同步"><a href="#为什么我的步数不能同步" class="headerlink" title="为什么我的步数不能同步"></a>为什么我的步数不能同步</h3><ol><li>成功提交，即乐心健康中有显示，却未同步至wx qq zfb 请参考上方使用说明，自行测试。如果还是同步不了，大可放弃使用，软件免费，我也没有什么精力做售后</li><li>如果提示未知，那么在cookie页面。长按删除，再重新返回主页面登录一次即可</li><li>登录时提示短信验证码已达上限，那么今天就无法使用验证码登录了，这个是官方的限制。第二天即可恢复</li></ol><h3 id="软件时常崩溃"><a href="#软件时常崩溃" class="headerlink" title="软件时常崩溃"></a>软件时常崩溃</h3><ol><li><p>应用基于安卓4.4开发，低于4.4无法使用</p></li><li><p>52pj为唯一发布平台，现移植到个人博客。如果遇到了非版本崩溃问题，请评论回复  在什么情况下遇到的问题+问题出现频率 </p></li></ol><h3 id="IOS可以使用吗"><a href="#IOS可以使用吗" class="headerlink" title="IOS可以使用吗"></a>IOS可以使用吗</h3><ol><li>目前只支持android并未支持ios</li></ol><h3 id="支持哪些应用改步数"><a href="#支持哪些应用改步数" class="headerlink" title="支持哪些应用改步数"></a>支持哪些应用改步数</h3><ol><li><p>支付宝</p></li><li><p>微信</p></li><li><p>QQ</p></li></ol><h3 id="需要root吗"><a href="#需要root吗" class="headerlink" title="需要root吗"></a>需要root吗</h3><p>不需要</p><h3 id="收费吗"><a href="#收费吗" class="headerlink" title="收费吗"></a>收费吗</h3><p>免费</p><h3 id="最高支持多少"><a href="#最高支持多少" class="headerlink" title="最高支持多少"></a>最高支持多少</h3><p>最高10W步  未具体测试</p><h3 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h3><p>第一次请使用手机号登录 然后修改，手机号每天只允许发送三次验证码（官方限制）且用且珍惜</p><p>使用手机号登录修改过之后，可以使用首页底部的使用cookie修改  不需要手机号登录即可  直到失效后 再次手机号登录一次就可以</p><h1 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h1><p>注册过账号之后，打开Cz步数助手进行账号登录</p><p>输入图片验证码以及短信验证码后 提示保存成功 </p><p>返回首页，使用cookie进行修改步数，以此避免每日短信3次上限</p><p>若cookie失效，请手动删除后再次短信登录，否则会提示保存失败</p><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/FABBB34A30DEB0D6FC396992E172E7E5.jpg" style="zoom:25%;" /><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/78D58C3360A125EE9BFD0428F62FF824.jpg" style="zoom: 25%;" /></p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>蓝奏云 <a href="https://chengzzz.lanzous.com/b0cqeofyb">https://chengzzz.lanzous.com/b0cqeofyb</a><br>密码:b42o</p><p>2020 8 12更新版本支持密码登录</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的安装使用</title>
      <link href="/2020/08/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/08/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-matery"><a href="#hexo-matery" class="headerlink" title="hexo+matery"></a>hexo+matery</h2>    <div id="aplayer-fubUhDae" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="首先安装nodejs，官网一键安装即可"><a href="#首先安装nodejs，官网一键安装即可" class="headerlink" title="首先安装nodejs，官网一键安装即可"></a>首先安装nodejs，官网一键安装即可</h3><h3 id="新建一个目录，并安装hexo"><a href="#新建一个目录，并安装hexo" class="headerlink" title="新建一个目录，并安装hexo"></a>新建一个目录，并安装hexo</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$  npm install -g hexo-cli</code></pre><h3 id="安装完成之后，使用hexo进行模板生成"><a href="#安装完成之后，使用hexo进行模板生成" class="headerlink" title="安装完成之后，使用hexo进行模板生成"></a>安装完成之后，使用hexo进行模板生成</h3><pre class="language-bash" data-language="bash"><code class="language-bash">Yet@DESKTOP-9S7FNJU MINGW64 &#x2F;g&#x2F;github&#x2F;blog$ hexo init</code></pre><h3 id="如果找不到hexo-那么将G-nodejs-node-global-node-modules-hexo-cli-bin-加入path-即-搜索hexo将bin加入环境变量"><a href="#如果找不到hexo-那么将G-nodejs-node-global-node-modules-hexo-cli-bin-加入path-即-搜索hexo将bin加入环境变量" class="headerlink" title="如果找不到hexo 那么将G:\nodejs\node_global\node_modules\hexo-cli\bin  加入path 即 搜索hexo将bin加入环境变量"></a>如果找不到hexo 那么将G:\nodejs\node_global\node_modules\hexo-cli\bin  加入path 即 搜索hexo将bin加入环境变量</h3><h3 id="如果提示：-hexo-server-Usage-hexo-，是因为hexo-3以后的版本需要手动安装server模块，执行下面的命令：npm-install-hexo-server-–save"><a href="#如果提示：-hexo-server-Usage-hexo-，是因为hexo-3以后的版本需要手动安装server模块，执行下面的命令：npm-install-hexo-server-–save" class="headerlink" title="如果提示： hexo server Usage: hexo ，是因为hexo 3以后的版本需要手动安装server模块，执行下面的命令：npm install hexo-server –save"></a>如果提示： hexo server Usage: hexo <command>，是因为hexo 3以后的版本需要手动安装server模块，执行下面的命令：npm install hexo-server –save</h3><pre class="language-bash" data-language="bash"><code class="language-bash">Yet@DESKTOP-9S7FNJU MINGW64 &#x2F;g&#x2F;github&#x2F;blog$ npm install hexo-server --save</code></pre><h3 id="如果提示"><a href="#如果提示" class="headerlink" title="如果提示"></a>如果提示</h3><p>ERROR Deployer not found: git</p><h3 id="那么输入以下命令即可"><a href="#那么输入以下命令即可" class="headerlink" title="那么输入以下命令即可"></a>那么输入以下命令即可</h3><pre class="language-bash" data-language="bash"><code class="language-bash">npm install &#96;--&#96;save hexo-deployer-git</code></pre><h3 id="返回目录，修改-config-yml中的deploy"><a href="#返回目录，修改-config-yml中的deploy" class="headerlink" title="返回目录，修改_config.yml中的deploy"></a>返回目录，修改_config.yml中的deploy</h3><pre class="language-yml" data-language="yml"><code class="language-yml">deploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;YYYet&#x2F;YYYet.github.io.git  branch: master</code></pre><h3 id="进行提交-g为生成静态页面-d为上传"><a href="#进行提交-g为生成静态页面-d为上传" class="headerlink" title="进行提交 g为生成静态页面 -d为上传"></a>进行提交 g为生成静态页面 -d为上传</h3><pre class="language-bash" data-language="bash"><code class="language-bash">Yet@DESKTOP-9S7FNJU MINGW64 &#x2F;g&#x2F;github&#x2F;blog$ hexo g -d</code></pre><p>此命令为开启本地调试 <a href="http://localhost:4000/">http://localhost:4000/</a></p><pre class="language-bash" data-language="bash"><code class="language-bash">Yet@DESKTOP-9S7FNJU MINGW64 &#x2F;g&#x2F;github&#x2F;blog$ hexo s</code></pre><h3 id="访问YYYet-github-io-git即可"><a href="#访问YYYet-github-io-git即可" class="headerlink" title="访问YYYet.github.io.git即可"></a>访问YYYet.github.io.git即可</h3>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
