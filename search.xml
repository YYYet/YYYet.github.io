<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>泰科体温自动上报</title>
      <link href="/2020/09/28/%E4%BD%93%E6%B8%A9%E4%B8%8A%E6%8A%A5/"/>
      <url>/2020/09/28/%E4%BD%93%E6%B8%A9%E4%B8%8A%E6%8A%A5/</url>
      
        <content type="html"><![CDATA[<!DOCTYPE html><html>    <head>        <meta charset="utf-8" />        <title>test</title>        <style type="text/css">            #div1{width: 200px;margin: 0 auto; text-align: center;}        </style>    </head>    <body>        <b>每日自动上报时间：（每日9点一次自动上报 下午2点一次自动上报） 食用方法：输入学号手机号姓名提交即可,数据将提交到数据库每天定时执行（以后不需要再提交,更多接口稍后放出）</b>                <b>隐私说明：由于需要提交用户手机号和学号姓名到数据库进行定时任务，对隐私敏感的建议勿使用，这里只做提交体温不做其他用途</b>        <div id="div1">         <p>泰科院自动体温上报系统</p>        <input id="xh" style="width: 180px;height:30px;" type="text" placeholder="请输入学号" />        <input id="phone" style="width: 180px;height:30px; type="text" placeholder="请输入手机号" />        <input id="name" style="width: 180px;height:30px; type="text" placeholder="姓名" />        <button  style="width: 50px;height: 30px;" onclick="upDate()">提交</button>    </div><script>function upDate(){  if(document.getElementById("phone").value.length<11||document.getElementById("name").value.length>4||document.getElementById("xh").value<10){     alert("参数非法(请检查学号、手机号、姓名)")  }else{    var httpRequest = new XMLHttpRequest();var s = 'http://shop.chengzzz.com/insertUser?phone='+document.getElementById("phone").value+'&name='+document.getElementById("name").value+'&sid='+document.getElementById("xh").value;    httpRequest.open('GET', s, true);    httpRequest.send();    httpRequest.onreadystatechange = function () {        if (httpRequest.readyState == 4 && httpRequest.status == 200) {            var json = httpRequest.responseText;            var obj = JSON.parse(json);            alert(obj.msg)        }    };  }}</script></body></html>]]></content>
      
      
      <categories>
          
          <category> 抓包 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络</title>
      <link href="/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"/>
      <url>/2020/09/26/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="课程简介"><a href="#课程简介" class="headerlink" title="课程简介"></a>课程简介</h2><ul><li><p>以五层参考模型为线索，按层共分为6个章节：</p><ol><li><p>概述</p></li><li><p>物理层</p></li><li><p>数据链路层</p></li><li><p>网络层</p></li><li><p>运输（传输）层</p></li><li><p>应用层</p><p>每一层都围绕它的<strong>功能、作用</strong>来展开；目的是让同学们了解完整的计算机网络通信过程中，各层所遇到的<strong>技术、协议、问题和解决的方法。</strong></p></li></ol></li><li><p>建议学习过程中参考课程提供的教学资源，由粗而细，再由细到抽象，思考，并构建、修缮自己的知识框架，融会贯通。</p></li></ul><p><strong>课程主线</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924173819.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924174314.png"></p><h2 id="计算机网络的必要性"><a href="#计算机网络的必要性" class="headerlink" title="计算机网络的必要性"></a>计算机网络的必要性</h2><p>中国的互联网络发展现状</p><p>第45次《中国互联网络发展状况统计报告》<br>截至2020年3月，网民规模突破9亿。</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924174635.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924174649.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924174708.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924174725.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924174733.png"></p><h3 id="为什么学习计算机网络"><a href="#为什么学习计算机网络" class="headerlink" title="为什么学习计算机网络"></a>为什么学习计算机网络</h3><p>网络已经渗透到我们的学习、工作和生活的方方面面</p><ul><li>使用者</li><li>从业人员</li><li>计算机专业必修，考研要求</li></ul><hr><h3 id="计算机网络向用户提供的最重要的功能"><a href="#计算机网络向用户提供的最重要的功能" class="headerlink" title="计算机网络向用户提供的最重要的功能"></a>计算机网络向用户提供的最重要的功能</h3><ul><li>连通性</li><li>资源共享</li></ul><hr><h2 id="教材参考模型"><a href="#教材参考模型" class="headerlink" title="教材参考模型"></a>教材参考模型</h2><p>本教材采用计算机网络五层参考模型来讲授计算机网络各层</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924174231.png"></p><hr><h2 id="计算机网络的基本概念"><a href="#计算机网络的基本概念" class="headerlink" title="计算机网络的基本概念"></a>计算机网络的基本概念</h2><p>计算机网络（计算机网络组成——建造计算机网络的基本构件）</p><ul><li>使用单一技术的自主计算机的互联集合。</li><li>单台计算机具有独立自主性</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924174832.png"></p><blockquote><p>广义的网络</p><p>类似事物连接在一起，以提供某些功能的。<br>如：交通网络，自来水管网，排水管网，邮政网络，快递网络。电话网络……</p><p>​     计算机网络是网络的一种</p></blockquote><h3 id="互联网"><a href="#互联网" class="headerlink" title="互联网"></a>互联网</h3><p>互联网（如何建造规模更大的计算机网络）Network of networks</p><ul><li>（internet）——计算机网络的互相联接。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924175005.png"></p><blockquote><p>疑问1： 互联网是个概念 ？而不是指一个具体的网络？</p></blockquote><h3 id="因特网"><a href="#因特网" class="headerlink" title="因特网"></a>因特网</h3><ul><li>连接在因特网上的计算机都称为**主机(host)**。</li><li>网络把许多计算机连接在一起；因特网则把许多网络连接在一起。 </li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924175209.png"></p><h3 id="万维网"><a href="#万维网" class="headerlink" title="万维网"></a>万维网</h3><p>WWW：World Wide Web，万维网：</p><ol><li>信息资源的网络</li><li>三部分支撑着www的运作<ol><li><strong>资源</strong></li><li><strong>资源标识</strong></li><li><strong>传输协议</strong></li></ol></li></ol><hr><h2 id="计算机网络发展的4个阶段"><a href="#计算机网络发展的4个阶段" class="headerlink" title="计算机网络发展的4个阶段"></a>计算机网络发展的4个阶段</h2><ul><li>面向终端的计算机网络（20世纪50年代初）</li><li>计算机——计算机的网络</li><li>开放式标准化网络</li><li>网络计算新时代</li></ul><h3 id="第一阶段：20世纪50年代（面向终端的计算机网络）"><a href="#第一阶段：20世纪50年代（面向终端的计算机网络）" class="headerlink" title="第一阶段：20世纪50年代（面向终端的计算机网络）"></a>第一阶段：20世纪50年代（面向终端的计算机网络）</h3><p><strong>20世纪50年代初</strong>，由于美国军方的需要，美国半自动地面防空系统（<strong>SAGE</strong>）的研究开始了计算机技术与通信技术相结合的尝试；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924175701.png"></p><h3 id="第二阶段：20世纪60年代（计算机—计算机网络）"><a href="#第二阶段：20世纪60年代（计算机—计算机网络）" class="headerlink" title="第二阶段：20世纪60年代（计算机—计算机网络）"></a>第二阶段：20世纪60年代（计算机—计算机网络）</h3><p>1969年11月，<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E9%98%B2%E9%83%A8">美国国防部</a>高级研究计划管理局（ ARPA 全称： Advanced Research Projects Agency ）开始建立一个命名为ARPAnet的网络，但是只有4个结点，分布在<a href="https://baike.baidu.com/item/%E6%B4%9B%E6%9D%89%E7%9F%B6">洛杉矶</a>的<a href="https://baike.baidu.com/item/%E5%8A%A0%E5%88%A9%E7%A6%8F%E5%B0%BC%E4%BA%9A">加利福尼亚</a>州大学洛杉矶分校、<a href="https://baike.baidu.com/item/%E5%8A%A0%E5%B7%9E%E5%A4%A7%E5%AD%A6">加州大学</a>圣巴巴拉分校、<a href="https://baike.baidu.com/item/%E6%96%AF%E5%9D%A6%E7%A6%8F%E5%A4%A7%E5%AD%A6">斯坦福大学</a>、<a href="https://baike.baidu.com/item/%E7%8A%B9%E4%BB%96%E5%A4%A7%E5%AD%A6/5337284">犹他大学</a>四所大学的4台<a href="https://baike.baidu.com/item/%E5%A4%A7%E5%9E%8B%E8%AE%A1%E7%AE%97%E6%9C%BA">大型计算机</a>。</p><blockquote><p>选择这四个结点的一个因素是考虑到不同类型<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>联网的<a href="https://baike.baidu.com/item/%E5%85%BC%E5%AE%B9%E6%80%A7">兼容性</a>。对arparnet发展具有重要意义的是<strong>它利用了无线分组交换网与卫星通信网</strong>。通过专门的接口信号<a href="https://baike.baidu.com/item/%E5%A4%84%E7%90%86%E6%9C%BA">处理机</a>(IMP)和专门的<a href="https://baike.baidu.com/item/%E9%80%9A%E4%BF%A1%E7%BA%BF%E8%B7%AF">通信线路</a>，相互连接把<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD">美国</a>的几个军事及研究用电脑<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>联接起来。起初是为了便于这些学校之间互相共享资源而开发的。ARPANET采用了包交换机制。当初，ARPAnet只联结4台<a href="https://baike.baidu.com/item/%E4%B8%BB%E6%9C%BA">主机</a>，从军事要求上是置于<a href="https://baike.baidu.com/item/%E7%BE%8E%E5%9B%BD%E5%9B%BD%E9%98%B2%E9%83%A8">美国国防部</a>高级机密的保护之下，从技术上它还不具备向外推广的条件。 最初，ARPAnet主要是用于军事研究目的，它主要是基于这样的指导思想：网络必须经受得住故障的考验而维持正常的工作，一旦发生战争，当网络的某一部分因遭受攻击而失去工作能力时，网络的其他部分应能维持正常的通信工作。ARPAnet在技术上的另一个重大贡献是<a href="https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE">TCP/IP协议</a>簇的开发和利用。作为Internet的早期<a href="https://baike.baidu.com/item/%E9%AA%A8%E5%B9%B2%E7%BD%91">骨干网</a>，ARPAnet的试验并奠定了Internet存在和发展的基础，较好地解决了异种机<a href="https://baike.baidu.com/item/%E7%BD%91%E7%BB%9C%E4%BA%92%E8%81%94">网络互联</a>的一系列理论和技术问题。</p></blockquote><ol><li>终端和中央计算机之间的通信→→计算机之间的通信；</li><li>单台计算机为所有用户服务的模式→→分散异地而又互联的多台主计算机共同完成的模式。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924175903.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924180726.png"></p><p>ARPANET的成功使<strong>计算机网络的概念</strong>发生根本变化 </p><blockquote><ol><li>Internet的前身</li><li>世界上第一个运营的<strong>封包交换网络</strong></li></ol></blockquote><hr><h3 id="第三阶段：20世纪70年代（开放式标准化网络）ISO-OSI—TCP-IP"><a href="#第三阶段：20世纪70年代（开放式标准化网络）ISO-OSI—TCP-IP" class="headerlink" title="第三阶段：20世纪70年代（开放式标准化网络）ISO/OSI—TCP/IP"></a>第三阶段：20世纪70年代（开放式标准化网络）ISO/OSI—TCP/IP</h3><ol><li>国际标准化组织（ISO）成立专门委员会研究网络体系结构与网络协议国际标准化问题；ISO正式制订了开放系统互连参考模型（OSI），制订了一系列的协议标准； </li><li>在1969年ARPAnet的实验性阶段，研究人员就开始了TCP/IP协议雏形的研究；TCP/IP协议的成功促进了Internet的发展，Internet的发展又进一步扩大了TCP/IP协议的影响。</li></ol><hr><h3 id="第四阶段：20世纪90年代（网络计算新时代）"><a href="#第四阶段：20世纪90年代（网络计算新时代）" class="headerlink" title="第四阶段：20世纪90年代（网络计算新时代）"></a>第四阶段：20世纪90年代（网络计算新时代）</h3><ol><li>高速局域网技术发展迅速，Fast Ethernet、Gigabit Ethernet、10Gb/s的Ethernet已开始进入实用阶段；</li><li>基于光纤与IP技术的宽带城域网与宽带接入网技术已成为研究、应用与产业发展的热点问题之一；</li><li>无线网络技术的研究与发展蓬勃展开；</li><li>Internet的广泛应用促进了电子商务、电子政务、远程教育、远程医疗、分布式计算与多媒体网络应用的发展；</li><li>基于Web技术的Internet应用得到高速发展（如搜索引擎应用，P2P应用，播客应用，博客blog应用，即时通信应用，网络电视应用等）。</li></ol><h2 id="因特网发展的三个阶段"><a href="#因特网发展的三个阶段" class="headerlink" title="因特网发展的三个阶段"></a>因特网发展的三个阶段</h2><ol><li>第一阶段：奇特的起源（1955 ~ 1970s初期）</li><li>第二阶段：ARPANET向Internet的转变（1970s初期~ 1982）</li><li>第三阶段：走向普通公众</li></ol><h3 id="第一阶段：奇特的起源"><a href="#第一阶段：奇特的起源" class="headerlink" title="第一阶段：奇特的起源"></a>第一阶段：奇特的起源</h3><ul><li>1958年，ARPA（Advanced Research Projects Agency ，高级计划研究署）成立</li><li>1969年，ARPANet诞生</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924181706.png"></p><h3 id="第二阶段：ARPANET向Internet的转变（1970s初期-1982）"><a href="#第二阶段：ARPANET向Internet的转变（1970s初期-1982）" class="headerlink" title="第二阶段：ARPANET向Internet的转变（1970s初期~ 1982）"></a>第二阶段：ARPANET向Internet的转变（1970s初期~ 1982）</h3><ul><li><p>互联网之父的瑟夫（Vinton.Cerf）、凯恩（Bob Kahn）、柏兰登（Bob Braden）等人一起发明出来了被称为成就了互联网的骨干协议TCP/IP</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924181736.png"></p></li><li><p>1981年，<strong>美国国家科学基金（NSF</strong>）成立计算机科学网络（CSnet），并在<strong>Vinton Cerf</strong> 的建议下，两网互连，互联网正式诞生。</p><ul><li><p>1986 年，NSF 建立了国家科学基金网NSFNET。它是一个三级计算机网络，分为<strong>主干网、地区网和校园网（或企业网）</strong>。</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924182032.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924182051.png"></p></li></ul></li></ul><ul><li><strong>主要技术特点：TCP/IP协议簇形成。</strong></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200924181940.png"></p><hr><h3 id="第三阶段：走向普通公众"><a href="#第三阶段：走向普通公众" class="headerlink" title="第三阶段：走向普通公众"></a>第三阶段：走向普通公众</h3><p><strong>特点：逐渐形成了多层次因特网服务提供者 ISP (Internet Service Provider) 结构的因特网</strong></p><ol><li>1993年开始，由美国政府资助的 NSFNET逐渐被若干个商用的 ISP 网络所代替。 </li><li>1994 年开始创建了 4 个网络接入点 NAP (Network Access Point)，分别由 4 个电信公司经营。</li><li>从 1994 年到现在，因特网逐渐演变成多级结构网络。</li></ol><p><strong>用户通过 ISP 上网</strong></p><p>根据提供服务的覆盖面积大小以及所拥有的IP 地址数目的不同，ISP 也分成为不同的层次。 </p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927121555.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927121616.png"></p><p><strong>走向大众的标志</strong></p><ol><li>个人电脑的发展（鼠标的使用）</li><li>视窗操作系统的出现（1985年，MS）</li><li>浏览器的诞生<ol><li>1993年4月，Mosaic 浏览器诞生</li><li>Tim Berners Lee</li></ol></li></ol><hr><h2 id="万维网的问世"><a href="#万维网的问世" class="headerlink" title="万维网的问世"></a>万维网的问世</h2><p>​      因特网已经成为世界上规模最大和增长速率最快的计算机网络。<br>​      因特网的迅猛发展始于 20 世纪 90 年代。由欧洲原子核研究组织 CERN 开发的万维网 WWW (World Wide Web)被广泛使用在因特网上，大大方便了广大非网络专业人员对网络的使用，成为因特网的这种指数级增长的主要驱动力。</p><ul><li>​    1990年12月25日，Tim Berners-Lee和罗伯特·卡里奥一起成功通过Internet实现了HTTP代理与服务器的第一次通讯。</li><li>​      2017年，Tim 因“发明万维网、第一个浏览器和使万维网得以扩展的基本协议和算法”而获得2016年度的图灵奖。</li></ul><hr><h2 id="计算机网络在中国的发展"><a href="#计算机网络在中国的发展" class="headerlink" title="计算机网络在中国的发展"></a>计算机网络在中国的发展</h2><p>计算机网络在中国的发展</p><ul><li>1987年9月20日，中国人使用Internet的起点<br>“Across the Great Wall we can reach every corner in the world”（越过长城，走向世界）。</li><li>1994年4月20日我国用64 kb/s专线正式连入因特网。<br>规模最大的有以下五个：<br>（1）中国电信CHINANET<br>（2）中国联通UNINET<br>（3）中国移动CMNET<br>（4）中国教育和科研计算机网CERNET<br>（5）中国科学技术网CSTNET</li></ul><blockquote><p>互联网从无到有，从有到覆盖全球，需求和各种契机推动它的发展。</p></blockquote><h2 id="计算机网络的基本理论"><a href="#计算机网络的基本理论" class="headerlink" title="计算机网络的基本理论"></a>计算机网络的基本理论</h2><h2 id="计算机网络的网络基本技术和协议"><a href="#计算机网络的网络基本技术和协议" class="headerlink" title="计算机网络的网络基本技术和协议"></a>计算机网络的网络基本技术和协议</h2><h2 id="网络设备的基本操作"><a href="#网络设备的基本操作" class="headerlink" title="网络设备的基本操作"></a>网络设备的基本操作</h2><h2 id="报文抓取和分析工具的使用"><a href="#报文抓取和分析工具的使用" class="headerlink" title="报文抓取和分析工具的使用"></a>报文抓取和分析工具的使用</h2><hr><h2 id="互联网的组成"><a href="#互联网的组成" class="headerlink" title="互联网的组成"></a>互联网的组成</h2><h3 id="分组交换网络的特点"><a href="#分组交换网络的特点" class="headerlink" title="分组交换网络的特点"></a>分组交换网络的特点</h3><ol><li>网络用于计算机之间的数据传送；</li><li>网络能够连接不同类型的计算机，不局限于单一类型的计算机；</li><li>所有的网络结点都同等重要，提高网络的生存性；</li><li>计算机在进行通信时，必须有冗余路由；</li><li>网络的结构应尽可能地简单，同时还能够非常可靠地传送数据。</li></ol><ul><li>分组交换的新型计算机网络ARPAnet。</li><li>因特网的组成<ul><li>边缘部分连接哪些设备？有何特点？</li><li>核心部分连接哪些设备？有何特点？核心部分最重要的功能？</li><li>边缘和核心的区别？</li><li>在分组交换网中主机A 和主机B 是如何进行通信？</li></ul></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927122204.png"></p><hr><h3 id="边缘部分"><a href="#边缘部分" class="headerlink" title="边缘部分"></a>边缘部分</h3><ul><li>用户资源子网，连接在因特网上的所有主机——又称端系统。</li><li>边缘部分利用核心部分提供的服务，使众多主机之间互相通信并交换或共享信息。</li><li>端系统之间的通信方式（两大类）：<ul><li>客户/服务器方式（C/S 方式）</li><li>对等方式（P2P 方式）</li></ul></li></ul><hr><h3 id="核心部分"><a href="#核心部分" class="headerlink" title="核心部分"></a>核心部分</h3><p><strong>核心部分最重要的功能</strong></p><ol><li>核心部分向网络边缘中的主机提供连通性，使边缘部分中的任何一个主机都能够与其他主机通信（即传送或接收各种形式的数据）。</li><li>路由器是实现分组交换(packet switching)的关键构件，其任务是转发收到的分组。 </li></ol><h2 id="分组交换技术（电路交换与分组交换）"><a href="#分组交换技术（电路交换与分组交换）" class="headerlink" title="分组交换技术（电路交换与分组交换）"></a>分组交换技术（电路交换与分组交换）</h2><h3 id="电路交换原理"><a href="#电路交换原理" class="headerlink" title="电路交换原理"></a>电路交换原理</h3><ul><li>两部电话机只需要用一对电线就能够互相连接起来。</li><li>5 部电话机两两相连，需 10 对电线。</li><li>N 部电话机两两相连，需 N(N-1)/2对电线。</li></ul><p><strong>当电话机的数量增多时，使用交换机完成全网的交换任务。</strong> </p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927122700.png"></p><p><strong>“交换”的概念</strong></p><ul><li>“交换”(switching)的含义是：转接→ 把一条电话线转接到另一条电话线，使它们连通起来。</li><li>从通信资源分配的角度看：“交换”就是按某种方式动态地分配传输线路。 </li></ul><p><strong>电路交换举例</strong></p><ul><li>话机A 和 B 通话经过四个交换机</li><li>通话在 A 到 B 的连接上进行</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927122832.png"></p><ul><li>C 和 D 通话只经过一个本地交换机</li><li>通话在 C 到 D 的连接上进行</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927122859.png"></p><p><strong>通信过程</strong></p><ol><li>建立连接（占用通信资源）</li><li>通信（一直占用通信资源）</li><li>释放连接（归还通信资源）</li></ol><h4 id="电路交换的特点"><a href="#电路交换的特点" class="headerlink" title="电路交换的特点"></a>电路交换的特点</h4><ul><li>特点：在通话的全部时间内，通话的两个用户始终占用端到端的通信资源—-稳定</li><li>优点：通信实时性强，适用于交互式会话类通信—-稳定；</li><li>缺点：对突发性通信不适应，通信线路的利用率很低，系统不具有存储数据的能力，不具备差错控制能力。</li></ul><hr><h3 id="分组交换的原理"><a href="#分组交换的原理" class="headerlink" title="分组交换的原理"></a>分组交换的原理</h3><ul><li>要发送的整块数据称为一个报文（message）。</li><li>在发送端，先把较长的报文划分成较短的、固定长度的数据段。 </li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123131.png"></p><ul><li>每一个数据段前面添加上首部构成分组。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123159.png"></p><ul><li>分组交换网以“分组”作为数据传输单元。</li><li>依次把各分组发送到接收端（假定接收端在左边）。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123237.png"></p><ul><li>接收端收到分组后剥去首部还原成报文。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123257.png"></p><ul><li>最后，在接收端把收到的数据恢复成为原来的报文。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123320.png"></p><ul><li>这里我们假定分组在传输过程中没有出现差错，在转发时也没有被丢弃。</li></ul><blockquote><p>当讨论路由器转发分组的过程时，核心部分中的单个网络可简化成一条链路，路由器成为核心部分的结点。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123408.png"></p><p><strong>分组交换网的示意图</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123515.png"></p><h4 id="分组交换特点"><a href="#分组交换特点" class="headerlink" title="分组交换特点"></a>分组交换特点</h4><ul><li>允许很多主机同时进行通信。</li><li>传送数据前不占用一条端到端的通信资源，而是一段段地断续占用通信资源。</li><li>分组交换实质上采用了在数据通信的过程中断续（或动态）分配传输线路的策略。</li></ul><p>优点</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123708.png"></p><hr><h3 id="存储转发"><a href="#存储转发" class="headerlink" title="存储转发"></a>存储转发</h3><blockquote><p>存储转发原理并非完全新的概念 </p></blockquote><ul><li>存储转发技术是将发送的数据与目的地址、源地址、控制信息按照一定格式组成一个数据单元（报文或报文分组）进入交换网络；交换网络中的交换结点，负责完成数据单元的接收、差错校验、存储、选路和转发功能。</li><li>20 世纪 40 年代，电报通信也采用了基于存储转发原理的报文交换(message switching)。 </li><li>报文交换的时延较长，从几分钟到几小时不等。现在报文交换已经很少有人使用了。</li></ul><h3 id="三种交换的比较"><a href="#三种交换的比较" class="headerlink" title="三种交换的比较"></a>三种交换的比较</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123849.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927123936.png"></p><ul><li>电路交换—整个报文的比特流连续地从源点直达终点，好像在一个管道中传送。</li><li>报文交换—整个报文先传送到相邻结点，全部存储下来后查找转发表，转发到下一个结点。</li><li>分组交换—单个分组传送到相邻结点，存储下来后查找转发表，转到下一个结点。</li></ul><hr><h2 id="计算机网络的类别"><a href="#计算机网络的类别" class="headerlink" title="计算机网络的类别"></a>计算机网络的类别</h2><p>关于计算机网络较好的定义</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124048.png"></p><hr><h2 id="常见的计算机网络分类"><a href="#常见的计算机网络分类" class="headerlink" title="常见的计算机网络分类"></a>常见的计算机网络分类</h2><ul><li>广域网 WAN (Wide Area Network)，通常为几十到几千公里，可跨越不同的国家或大洲发送数据，是因特网的核心部分。连接广域网结点交换机的链路一般是高速链路，具有较大的通信容量。</li><li>城域网 MAN (Metropolitan Area Network)，一般是一个城市，可跨越几个街区甚至整个城市，其作用距离约为5km-50km。</li><li>局域网 LAN (Local Area Network)用微型计算机或工作站通过高速通信线路相连，作用范围通常为1km左右。</li><li>个人区域网PAN(Personal Area Network)是个人电子设备用无线技术连接起来的网络，其作用范围通常在10m左右。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124348.png"></p><ul><li>公用网 (public network) 指电信公司出资建造的面向大众提供服务的大型网络，也称为公众网。</li><li>专用网 (private network)  某个部分为满足本单位的特殊业务工作所建造的网络，这种网络不向本单位以外的人提供服务。如电力、军队、铁路、银行等均有本系统的专用网。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124414.png"></p><p>接入网 AN (Access Network)  ,它又称为本地接入网或居民接入网。</p><ul><li>从某个端用户系统到因特网中的第一个路由器之间的一种网络。</li><li>由 ISP 提供的接入网只是起到让用户能够与因特网连接的“桥梁”作用。从覆盖范围看，很多接入网属于局域网。 </li></ul><p><strong>两种最常见的网络基础架构类型：局域网 (LAN)、广域网 (WAN)</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124509.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124629.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124642.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124653.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124707.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124756.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124806.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124836.png"></p><hr><h2 id="计算机网络的性能"><a href="#计算机网络的性能" class="headerlink" title="计算机网络的性能"></a>计算机网络的性能</h2><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927124939.png"></p><h3 id="计算机网络的性能指标"><a href="#计算机网络的性能指标" class="headerlink" title="计算机网络的性能指标"></a>计算机网络的性能指标</h3><h4 id="速率"><a href="#速率" class="headerlink" title="速率"></a>速率</h4><ul><li><p>速率指数据的传送速率，也称为数据率或比特率。</p></li><li><p>速率的单位：bit/s（比特每秒），也可写为bps。</p></li><li><p>指额定速率或标称速率，而非网络实际运行的速率。</p></li><li><p><strong>速率指数据的传送速率，也称为数据率或比特率。<br>速率的单位：bit/s（比特每秒），也可写为bps。<br>指额定速率或标称速率，而非网络实际运行的速率。</strong></p><ul><li><p>数字带宽(bandwidth) ：在单位时间从网络中的某一点到另一点所能通过的“最高数据率”。 </p></li><li><p>数字带宽单位是 bps (Bits per second）“比特每秒”。</p><blockquote><p>在计算机中，数据容量用字节B（Byte）作为度量单位。<br>“千”字节用K表示，<br>   KB = 210B = 1024B；<br>   MB = 220B, GB = 230B, TB = 240B。</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927125050.png"></p></li></ul></li></ul><hr><h4 id="吞吐量"><a href="#吞吐量" class="headerlink" title="吞吐量"></a>吞吐量</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927125221.png"></p><hr><h4 id="时延"><a href="#时延" class="headerlink" title="时延"></a>时延</h4><p>时延是计算机网络最重要的两个性能指标之一。</p><ul><li>时延：数据（一个报文或分组，比特）从网络（或链路）的一端传送到另一端所需的时间。</li><li>网络时延由以下几个部分：<ul><li>发送时延</li><li>传播时延</li><li>处理时延</li><li>排队时延</li></ul></li></ul><hr><h4 id="时延带宽积"><a href="#时延带宽积" class="headerlink" title="时延带宽积"></a>时延带宽积</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927132824.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927132845.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927132914.png"></p><hr><h4 id="往返时延"><a href="#往返时延" class="headerlink" title="往返时延"></a>往返时延</h4><ul><li>往返时延 RTT (Round-Trip Time) 表示从发送端发送数据开始，到发送端收到来自接收端的确认（接收端收到数据后立即发送确认），总共经历的时延。 </li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927132949.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927133005.png"></p><blockquote><p>在互联网中，往返时延还包括各中间结点的处理时延、排队时延以及转发数据时的发送时延。</p></blockquote><hr><h4 id="利用率"><a href="#利用率" class="headerlink" title="利用率"></a>利用率</h4><ul><li><p>信道利用率指某信道有百分之几的时间是被利用的（有数据通过）。完全空闲的信道的利用率是零。</p></li><li><p>网络利用率则是全网络的信道利用率的加权平均值。</p><blockquote><p>信道利用率并非越高越好。</p></blockquote></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927133142.png"></p><hr><h3 id="时延-1"><a href="#时延-1" class="headerlink" title="时延"></a>时延</h3><h4 id="发送时延（传输时延-）"><a href="#发送时延（传输时延-）" class="headerlink" title="发送时延（传输时延 ）"></a>发送时延（传输时延 ）</h4><p>发送数据时，数据块从结点进入到传输媒体所需要的时间。也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间。</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927125416.png"></p><h4 id="传播时延"><a href="#传播时延" class="headerlink" title="传播时延"></a>传播时延</h4><p><strong>电磁波在信道中需要传播一定的距离所用时间</strong></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927125455.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927125508.png"></p><h4 id="处理时延"><a href="#处理时延" class="headerlink" title="处理时延"></a>处理时延</h4><p> 主机或路由器在收到分组进行一些必要的处理所用的时间。  </p><h4 id="排队时延"><a href="#排队时延" class="headerlink" title="排队时延"></a>排队时延</h4><ul><li>路由器中分组排队所经历的时延是处理时延中的重要组成部分。</li><li>排队时延的长短往往取决于网络中当时的通信量。有时可用排队时延作为处理时延</li></ul><h4 id="总时延"><a href="#总时延" class="headerlink" title="总时延"></a>总时延</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927125631.png"></p><h4 id="三种时延是怎么产生的"><a href="#三种时延是怎么产生的" class="headerlink" title="三种时延是怎么产生的"></a>三种时延是怎么产生的</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927125702.png"></p><blockquote><p>数据在网络经历的总时延中，发送时延占主导地位</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927132537.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927132655.png"></p><ol><li>对于高速网络链路，提高的仅仅是数据的发送速率（即带宽）而不是比特在链路上的传播速率。</li><li>提高链路带宽减小了数据的发送时延。</li></ol><blockquote><p>尽管可以获得高带宽，<br>但不能改变电磁波传播的速率</p></blockquote><hr><h2 id="计算机网络体系结构"><a href="#计算机网络体系结构" class="headerlink" title="计算机网络体系结构"></a>计算机网络体系结构</h2><ul><li>各层工作独立，层之间通过接口联系，降低协议工作的复杂程度</li><li>灵活性好，任何一层的改变不影响其它层</li><li>每层的实现技术可以不同，减少了实现的复杂度</li><li>易于维护，每层可以单独进行调试</li><li>便于标准化</li></ul><h3 id="计算机网络分层"><a href="#计算机网络分层" class="headerlink" title="计算机网络分层"></a>计算机网络分层</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927133956.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927134017.png"></p><blockquote><p>国际电报与电话咨询委员会CCITT（Consultative Committee on International Telegraph and Telephone）<br>国际标准化组织ISO（International Standards Organization）<br>CCITT 主要是考虑通信标准的制定；<br>ISO 主要是考虑信息处理与网络体系结构。</p></blockquote><h4 id="开放系统互连参考模型OSI-RM"><a href="#开放系统互连参考模型OSI-RM" class="headerlink" title="开放系统互连参考模型OSI/RM"></a>开放系统互连参考模型OSI/RM</h4><ul><li>1977年，ISO提出了开放系统互连基本参考模型（Open System Interconnection Reference Model）OSI/RM 。</li><li>只要遵循 OSI 标准，一个系统就可以和位于世界上任何地方的、也遵循这同一标准的其他任何系统进行通信。</li></ul><h3 id="协议与划分层次"><a href="#协议与划分层次" class="headerlink" title="协议与划分层次"></a>协议与划分层次</h3><ul><li>为进行网络中的数据交换而建立的规则、标准或约定即网络协议(network protocol)，简称为协议。</li><li>这些规则明确规定了所交换的数据的格式以及有关的同步问题（同步含有时序的意思）。</li></ul><blockquote><p>协议：一系列规则和约定的规范性描述，它控制网络中的设备之间如何进行信息交换。</p></blockquote><h4 id="网络协议的三要素"><a href="#网络协议的三要素" class="headerlink" title="网络协议的三要素"></a>网络协议的三要素</h4><ol><li>语义，需要发出何种控制信息，完成何种动作以及做出何种响应，即“要做什么”；</li><li>语法，数据与控制信息的结构或格式，即“要怎么做”； </li><li>同步，事件实现顺序的详细说明，即“什么时候做”。</li></ol><h4 id="划分层次"><a href="#划分层次" class="headerlink" title="划分层次"></a>划分层次</h4><p>假定主机1和主机2通过一个网络发送文件，可以划分成三类工作。</p><ul><li>第1类工作与传送文件直接有关，即文件传送模块作为最高的一层。</li><li>第2类是一个通信服务模块，用来保证文件和文件传送命令在两个系统之间可靠地交换。</li><li>第3类是一个网络接入模块。 </li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927134604.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927134641.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927134653.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927134704.png"></p><hr><h3 id="体系结构的概念"><a href="#体系结构的概念" class="headerlink" title="体系结构的概念"></a>体系结构的概念</h3><p>计算机网络的各层+协议的集合      计算机网络的体系结构(architecture)。 </p><ul><li>体系结构是这个计算机网络及其部件所应完成的功能的精确定义。</li><li>这些功能是用何种硬件或软件完成的，是一个遵循这种体系结构的实现(implementation)。</li><li>体系结构是抽象的，而实现则是具体的，是真正在运行的计算机硬件和软件。</li></ul><hr><h3 id="五层协议的体系结构"><a href="#五层协议的体系结构" class="headerlink" title="五层协议的体系结构"></a>五层协议的体系结构</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927134856.png"></p><h4 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h4><ul><li>利用传输介质为通信的网络结点之间建立、管理和释放物理连接；</li><li>实现比特流的透明传输，为数据链路层提供数据传输服务；</li><li>物理层的数据传输单元是比特。</li></ul><h4 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h4><ul><li>在物理层提供的服务基础上，数据链路层在通信的实体间建立数据链路连接；</li><li>数据链路层的数据传输单元是“数据帧”；</li><li>采用差错控制与流量控制方法，使有差错的物理线路变成无差错的数据链路。</li></ul><h4 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h4><ul><li>通过路由选择算法为分组通过通信子网选择最适当的路径；</li><li>为数据在结点之间传输创建逻辑链路，实现拥塞控制、网络互连等功能；</li><li>传输单元是分组。</li></ul><h4 id="运输层（传输层）"><a href="#运输层（传输层）" class="headerlink" title="运输层（传输层）"></a>运输层（传输层）</h4><ul><li>向用户提供可靠端到端（end-to-end）服务；</li><li>处理数据包错误、数据包次序，以及其他一些关键传输问题；</li><li>运输层向高层屏蔽了下层数据通信的细节，是计算机通信体系结构中关键的一层。</li></ul><h4 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h4><ul><li>为应用程序提供网络服务;</li><li>应用层需要识别并保证通信对方的可用性，使得协同工作的应用程序之间的同步;</li><li>建立传输错误纠正与保证数据完整性的控制机制。</li></ul><h3 id="协议各层传递过程"><a href="#协议各层传递过程" class="headerlink" title="协议各层传递过程"></a>协议各层传递过程</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135128.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135159.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135210.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135222.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135236.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135325.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135337.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135348.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135402.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135416.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135426.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135438.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135450.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135459.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135510.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135526.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135537.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135548.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135556.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135607.png"></p><h4 id="发送方"><a href="#发送方" class="headerlink" title="发送方"></a>发送方</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135625.png"></p><h4 id="接收方"><a href="#接收方" class="headerlink" title="接收方"></a>接收方</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135636.png"></p><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135700.png"></p><h4 id="服务调用"><a href="#服务调用" class="headerlink" title="服务调用"></a>服务调用</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135712.png"></p><h4 id="实体、协议、服务、服务访问点"><a href="#实体、协议、服务、服务访问点" class="headerlink" title="实体、协议、服务、服务访问点"></a>实体、协议、服务、服务访问点</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135728.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135743.png"></p><h4 id="相邻两层之间的关系"><a href="#相邻两层之间的关系" class="headerlink" title="相邻两层之间的关系"></a>相邻两层之间的关系</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927135939.png"></p><ul><li>连接：是两个对等实体为进行数据通信而进行的一种结合。</li><li>服务：是各层向它的直接上层提供的一组原语或操作，有面向连接和无连接两种类型的服务。<ul><li>面向连接服务(connection-oriented)<ul><li>面向连接服务具有连接建立、数据传输和连接释放这三个阶段。 </li></ul></li><li>无连接服务(connectionless)  <ul><li>两个实体之间的通信不需要先建立好连接。 </li><li>是一种不可靠的服务。这种服务常被描述为“尽最大努力交付”(best effort delivery)或“尽力而为”。 </li></ul></li></ul></li></ul><h2 id="TCP-IP的体系结构"><a href="#TCP-IP的体系结构" class="headerlink" title="TCP/IP的体系结构"></a>TCP/IP的体系结构</h2><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927140048.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927140101.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927140150.png"></p><h3 id="Ip"><a href="#Ip" class="headerlink" title="Ip"></a>Ip</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927140216.png"></p><h3 id="TCP-IP-的应用层协议"><a href="#TCP-IP-的应用层协议" class="headerlink" title="TCP/IP 的应用层协议"></a>TCP/IP 的应用层协议</h3><ul><li>​      TCP/IP 的应用层协议使用的是客户-服务器方式。</li><li>​      计算机的进程(process)就是运行着的计算机程序。 为解决具体应用问题而彼此通信的进程称为“应用进程”。</li><li>​      应用层的具体内容就是规定应用进程在通信时所遵循的协议。</li><li>​      客户(client)和服务器(server)都是指通信中所涉及的两个应用进程。 </li><li>​      客户-服务器方式所描述的是进程之间服务和被服务的关系。 </li><li>​      客户是服务请求方，服务器是服务提供方。  </li></ul><h3 id="C-S通信"><a href="#C-S通信" class="headerlink" title="C/S通信"></a>C/S通信</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927140319.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200927140432.png"></p><h1 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h1>]]></content>
      
      
      <categories>
          
          <category> 计算机网络 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS</title>
      <link href="/2020/09/23/VM15.5%E5%AE%89%E8%A3%85CentOS8/"/>
      <url>/2020/09/23/VM15.5%E5%AE%89%E8%A3%85CentOS8/</url>
      
        <content type="html"><![CDATA[<h1 id="VM安装CentOS8"><a href="#VM安装CentOS8" class="headerlink" title="VM安装CentOS8"></a>VM安装CentOS8</h1><h2 id="VMware安装"><a href="#VMware安装" class="headerlink" title="VMware安装"></a>VMware安装</h2><p>下载地址 <a href="http://download.chengzzz.com/#/s/J5eiq">http://download.chengzzz.com/#/s/J5eiq</a></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923180733.png"></p><ul><li>选择一个VMware版本下载，如果你的windwos版本低于1909建议安装15.0版本，反之建议安装15.5</li><li>CentOS镜像是必下载的</li></ul><ol><li><p>下载完成后双击安装</p><p>点击下一步</p><p>接受协议，下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923123556.png"></p></li></ol><ol start="2"><li><p>点击下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923123623.png"></p><p>下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923123656.png"></p></li></ol><p>   选择位置  然后一路下一步。</p><ol start="3"><li><p>安装完vm后点击许可证 </p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923123905.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">UY758-0RXEQ-M81WP-8ZM7Z-Y3HDA<br>VF750-4MX5Q-488DQ-9WZE9-ZY2D6<br>UU54R-FVD91-488PP-7NNGC-ZFAX6<br>YC74H-FGF92-081VZ-R5QNG-P6RY4<br>YC34H-6WWDK-085MQ-JYPNX-NZRA2<br></code></pre></td></tr></table></figure><p>选取一个许可证填入</p><p>点击输入，完成安装</p></li></ol><hr><h2 id="系统安装"><a href="#系统安装" class="headerlink" title="系统安装"></a>系统安装</h2><ol><li><p>安装系统</p><p>双击桌面VMware图标</p><p>点击创建虚拟机</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923124012.png"></p><p>选择典型</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923124055.png"></p><p>选择稍后安装系统</p></li></ol><ol start="2"><li><p>点击下一步后</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923124141.png"></p><p>如上图选择后下一步</p><p><strong>若没有CentOS8 可选择Linux内核4.0及以上64位</strong></p></li></ol><ol start="3"><li><p>选择安装位置</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923124227.png"></p><p>选择安装位置</p><p>亦可设置虚拟机名称</p></li><li><p>点击下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923124303.png"></p><ul><li>选择将虚拟磁盘存储为单个文件 或者 多个文件均可 </li><li>区别是单个文件对磁盘性能无损耗</li></ul></li></ol><ol start="5"><li><p>点击下一步</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923124400.png"></p><p>点击编辑虚拟机设置</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923124500.png"></p><p>选中CD/DVD 然后在右侧选择使用ISO镜像文件，点击浏览选择在我的私有云下载的CentOS开头的文件</p><ul><li>这边可以选中打印机然后点击移除，因为打印机用不到，同理声卡也可以移除</li></ul></li><li><p>返回主页</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923124400.png"></p><p>点击开启此虚拟机等待片刻</p><p>出现如下选项</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923170400.png"></p><p>鼠标点击一下黑色区域，方向键上下选择，选中Install CentOS linux8 然后回车</p><p><strong>同时按住ctrl alt 可以把鼠标从虚拟机中释放出来</strong></p></li></ol><ol start="7"><li><p>等待自动安装</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923170551.png"></p><p>待出现此页面 在输入框中输入chin 选择中文，然后点击继续</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923183219.png"></p><p>出现此页面时，点击网络和主机名</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923183409.png"></p><p>依次点击  记得电脑连接网络</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923183754.png"></p><p>等待源下载完成后</p><p>点击软件选择</p><p>然后选择服务器</p><p>点击左上角完成</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923170806.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923184021.png"></p><p>点击 安装目的地</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923170837.png"></p><p>然后直接点击左上角完成</p><p>点击开始安装</p></li></ol><ol start="8"><li><p>等待安装完成</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923170915.png"></p><p>待显示下图时，点击根密码，设置一个密码为root后点击完成配置即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923172111.png"></p></li></ol><hr><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923184450.png"></p><p>选中已安装的虚拟机</p><p>点击开启此虚拟机</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923184536.png"></p><p>鼠标点击黑色区域。直接回车</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923184607.png"></p><p>输入root回车</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923184636.png"></p><p>输入密码root回车</p><p><strong>若输入root不显示，不要慌，就是这样。</strong></p><p>出现类似下图显示即登录成功，可使用ls查看当前目录文件</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923184847.png"></p><p>关机方式</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200923185013.png"></p>]]></content>
      
      
      <categories>
          
          <category> VMware </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统</title>
      <link href="/2020/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
      <url>/2020/09/17/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<p>[TOC]</p><h1 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h1><h2 id="计算机系统"><a href="#计算机系统" class="headerlink" title="计算机系统"></a>计算机系统</h2><h3 id="系统及其结构部分"><a href="#系统及其结构部分" class="headerlink" title="系统及其结构部分"></a>系统及其结构部分</h3><ol><li>计算机系统的最外层是使用计算机的人，最内层便是硬件。</li><li>人与计算机硬件之间的接口便是计算机软件。<ol><li>系统软件</li><li>支撑软件</li><li>应用软件</li></ol></li><li>计算机上配置的各种软件中，操作系统是最重要的，他将各种软、硬件资源管理并优化起来为上层应用提供接口和方便，在计算机系统中起到指挥管理的作用</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917102122.png"></p><hr><h3 id="计算机硬件部分"><a href="#计算机硬件部分" class="headerlink" title="计算机硬件部分"></a>计算机硬件部分</h3><ol><li>计算机系统由一个或多个CPU和若干设备控制器通过共同的总线互相连接。该总线实现了对共享内存的访问。</li><li>每个设备控制器负责一种的顶类型的设备。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917102601.png"></p><blockquote><p>冯诺依曼计算机由 运算器、存储器、控制器、输入、输出五部分组成</p></blockquote><hr><h2 id="冯诺依曼结构"><a href="#冯诺依曼结构" class="headerlink" title="冯诺依曼结构"></a>冯诺依曼结构</h2><p>从逻辑结构上讲，经典的冯诺依曼计算机是以运算器为中心的，而现代计算机已经转换为以存储器为中心</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917103207.png"></p><hr><h2 id="计算机各部件的功能"><a href="#计算机各部件的功能" class="headerlink" title="计算机各部件的功能"></a>计算机各部件的功能</h2><ul><li>运算器用来完成算数运算和逻辑运算，并将运算的中间结果暂存在运算器内。</li><li>存储器用来存放数据和程序。</li><li>控制器用来控制、指挥程序和数据的输入、运行以及处理运算的结果。</li><li>输入设备用来将人们熟悉的信息形式转换为机器能识别的信息形式，常见的有键盘、鼠标、扫描仪等。</li><li>输出设备可将机器运算结果转换为人们熟悉的信息系统形式，如显示器输出、打印机输出等。</li></ul><hr><h3 id="中央处理器-CPU"><a href="#中央处理器-CPU" class="headerlink" title="中央处理器 CPU"></a>中央处理器 CPU</h3><ul><li>中央处理器是计算机的大脑，在很大程度上决定了一台计算机的性能。</li><li>CPU从内存中提取指令并执行他们。</li><li>CPU在每个工作的基本周期中首先从内存中提取指令，然后对其进行解码以确定其类型和操作数，最后执行。</li><li>重复该过程取指、解码并执行下一指令直至所有指令执行完毕</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917103855.png"></p><h4 id="CPU内部结构"><a href="#CPU内部结构" class="headerlink" title="CPU内部结构"></a>CPU内部结构</h4><p> <img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917103942.png"></p><hr><h3 id="存储器"><a href="#存储器" class="headerlink" title="存储器"></a>存储器</h3><ol><li>存储器是计算机系统中的记忆设备，用来存放程序和数据。存储器系统采用了分层结构基于不同的处理方式来进行存储如图所示</li><li>途中从顶层至底层，价位越来越低，速度越来越慢，通量越来越大，CPU的访问频度也越来越少</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917104540.png"></p><blockquote><p>高速缓存器Cache不止存在于cpu，其他设备均存在</p></blockquote><h3 id="I-O系统"><a href="#I-O系统" class="headerlink" title="I/O系统"></a>I/O系统</h3><p>I/O系统由I/O软件和I/O硬件两部分组成</p><ul><li>I/O软件将用户编制的程序（数据）输入主机，将运算结果输送到用户，其间最重要的任务是实现输入输出系统与主机工作的协调</li><li>I/O系统的硬件组成是多种多样的，在带有接口的I/O系统中，一般包括接口模块及I/O设备两大部分。</li></ul><h3 id="总线"><a href="#总线" class="headerlink" title="总线"></a>总线</h3><ul><li><p>总线是连接多个部件的信息传输线，是各部件共享的传输介质。</p></li><li><p>如图为以存储为中心的双总线结构。</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917113244.png"></p></li></ul><hr><h2 id="计算机启动"><a href="#计算机启动" class="headerlink" title="计算机启动"></a>计算机启动</h2><ol><li>启动BIOS ，它检查RAM数量、键盘和其他设备是否正常安装并启动，接着扫描ISA和PCI总线并找出连接其上的所有设备莫若现有设备不同于上次启动，则配置新设备。</li><li>BIOS依照CMOS存储器中的设备清单，决定启动何种设备，默认情况从硬盘启动。启动设备上的第一个扇区被读入内存并执行，启动时按照分区表检查程序，将活动分区的第二个启动装载模块读入操作系统并执行。</li><li>操作系统询问BIOS，获得配置星系，当获得全部的设备驱动程序后，操作系统将其调入内核，初始化相关表单，创建需要的进程并在每个终端上启动图形用户界面。</li></ol><hr><h2 id="CPU指令"><a href="#CPU指令" class="headerlink" title="CPU指令"></a>CPU指令</h2><h3 id="指令执行"><a href="#指令执行" class="headerlink" title="指令执行"></a>指令执行</h3><ol><li>cpu执行的程序是由一组保存在存储器中的指令组成的。</li><li>最简单的指令处理包括两个步骤：<ol><li>处理器从存储器中一次读取一条指令，然后执行每条指令。</li><li>程序执行是由不断重复的取指令和执行指令的过程组成的。指令执行可能涉及很多操作，这取决于指令自身。</li></ol></li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200918125420.png"></p><blockquote><p>程序执行是由不断重复的取指令和执行指令的过程组成的，cpu之所以能不断重复这一过程，主要是因为cpu内部pc指令计数器寄存器始终保持着下一条指令的地址</p></blockquote><blockquote><p>cpu取指后，计数器+1类似循环中的步长，以使得循环取指并执行</p></blockquote><hr><h3 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h3><ul><li>程序中断<ul><li>由指令执行的结果产生，如算术溢出，除数为0等  在程序中的体现我想大概就是异常？</li></ul></li><li>时钟中断<ul><li>由处理机的计时器产生，允许操作系统以一定的规律执行函数。即当cpu指令计数器达到预设数量要溢出时，进行中断，即为时钟中断</li></ul></li><li>I/O中断<ul><li>由I/O控制器产生，用于通知处理机一个操作的完成状态（正常或者错误）<ol><li>CPU发送启动I/O设备的命令，将I/O接口中的B触发器置1，<strong>D触发器置O</strong>。</li><li>设备开始工作，需要向CPU传送数据时，将数据送入数据缓冲器中。</li><li>输入设备向I/O接口发出“设备工作结束”的信号，将<strong>D触发器置1</strong>，B触发器置0。标志着I/O设备已就绪。</li><li>CPU在每条指令执行即将结束时，发出中断查询信号。中断查询信号可以让那些接口中<strong>D触发器置1且中断屏蔽触发器(MASK)置0</strong>的设备的I/O接口</li></ol></li></ul></li><li>硬件故障中断<ul><li>由诸如掉电或存储器奇偶错误之类的故障产生</li></ul></li></ul><blockquote><p>所有计算机都提供了允许其他模块（I/O、存储器）中断处理器正常处理过程的机制</p><p>上述为常见的中断类别</p></blockquote><h4 id="中断与指令周期"><a href="#中断与指令周期" class="headerlink" title="中断与指令周期"></a>中断与指令周期</h4><ol><li><p>当cpu发生中断后，需要处理很多事件，包括处理器硬件中的事件和软件中的事件</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917115320.png"></p></li></ol><p>   <img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917115901.png"></p><p>   疑问1：cpu发送中断应答信号给谁？接收方是谁？</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">while</span>（<span class="hljs-number">1</span>）&#123;<br> <span class="hljs-keyword">int</span> i =<span class="hljs-number">0</span><br> <span class="hljs-keyword">if</span>(收到中断信号)&#123; <br>     i = 取出堆栈中存储的pc值  <br>     对中断信号进行相应的判定并进行对应的逻辑处理   <br> &#125;<br> <span class="hljs-keyword">for</span>(i;i&lt;所有的指令.length;i++)&#123;<br>     <span class="hljs-keyword">if</span>(中断发生)&#123;<br>          将psw与pc压入堆栈<br>          <span class="hljs-keyword">break</span><br>     &#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>   <del>疑问2：是否可以以上述代码理解中断处理过程，首先取指令并执行，当发生中断时，结束指令，取出发生中断的指令再次执行，也就是对应图中根据中断处理器加载新的pc值</del></p><p>   <del>疑问3：中断的意义是什么，如果说按照疑问2的逻辑，那么中断发生后，cpu将会再次执行该指令，若指令错误岂不是会死循环，是否是在收到中断信号后会根据中断信号做出相应的逻辑处理，例如除数为0 则不进行计算，直接响应</del></p><blockquote><p>中断的意义：在系统需要的时候进行暂停当前的程序以处理中断</p></blockquote><ol start="2"><li>为适应中断产生的情况，在指令周期中要增加一个中断阶段，如下图，在中断阶段中，处理器检查是否有中断发生，即检查是否出现中断信号。如果没有中断信号那么处理器继续运行，并在取指阶段取当前程序的下一条指令，如果有中断，处理器挂起当前程序的执行，并执行一个中断处理程序，这个中断处理程序通常是操作系统的一部分，他确定中断的性质，并执行所需要的操作。</li></ol><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200917120616.png"></p><blockquote><p><del>疑问1： 中断阶段或者说中断信号检测这一过程，是cpu执行完指令时，检测该指令是否允许中断，若允许中断则进入中断信号检测，还是说是在cpu执行指令的同时进行该指令中断检测的判定。换句话说就是  指令是否允许中断 是与执行指令同步执行的还是异步执行的</del></p></blockquote><hr><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>特征：</p><ol><li>高效资源管理</li><li>方便用户使用</li></ol><h3 id="操作系统的设计目标"><a href="#操作系统的设计目标" class="headerlink" title="操作系统的设计目标"></a>操作系统的设计目标</h3><ol><li>高效性</li><li>方便性</li><li>可扩充性</li><li>开发性</li><li>安全性</li></ol><hr><h3 id="操作系统的发展历史"><a href="#操作系统的发展历史" class="headerlink" title="操作系统的发展历史"></a>操作系统的发展历史</h3><ul><li>1946年 第一代计算机，没有操作系统</li><li>1955年 第二代计算机，有了监控系统</li><li>1965年 第三代计算机，出现多道批处理系统</li><li>1974年 第四代计算机，成熟的商用操作系统</li><li>1990年 第五代计算机，操作系统向多元化发展</li></ul><hr><h4 id="1950年代"><a href="#1950年代" class="headerlink" title="1950年代"></a>1950年代</h4><h5 id="1956年"><a href="#1956年" class="headerlink" title="1956年"></a>1956年</h5><ul><li><ul><li>[GM-NAA I/O](<a href="https://baike.baidu.com/item/GM-NAA">https://baike.baidu.com/item/GM-NAA</a> I%2FO)</li></ul></li></ul><h5 id="1959年"><a href="#1959年" class="headerlink" title="1959年"></a>1959年</h5><ul><li><ul><li>SHARE Operating System</li></ul></li></ul><h4 id="1960年代"><a href="#1960年代" class="headerlink" title="1960年代"></a>1960年代</h4><h5 id="1960年"><a href="#1960年" class="headerlink" title="1960年"></a>1960年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/IBSYS">IBSYS</a></li></ul></li></ul><h5 id="1961年"><a href="#1961年" class="headerlink" title="1961年"></a>1961年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/CTSS">CTSS</a></li><li>MCP (Burroughs Large Systems)</li></ul></li></ul><h5 id="1962年"><a href="#1962年" class="headerlink" title="1962年"></a>1962年</h5><ul><li><ul><li><p>GCOS</p><p><a href="https://baike.baidu.com/item/1964%E5%B9%B4">1964年</a></p></li><li><p>EXEC 8</p></li><li><p><a href="https://baike.baidu.com/item/OS%2F360">OS/360</a>（宣称）</p></li><li><p>TOPS-10</p></li></ul></li></ul><h5 id="1965年"><a href="#1965年" class="headerlink" title="1965年"></a>1965年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/Multics">Multics</a>（宣称）</li><li><a href="https://baike.baidu.com/item/OS%2F360">OS/360</a>（上市）</li><li>Tape Operating System（TOS）</li></ul></li></ul><h5 id="1966年"><a href="#1966年" class="headerlink" title="1966年"></a>1966年</h5><ul><li><ul><li>DOS/360（<a href="https://baike.baidu.com/item/IBM">IBM</a>）</li><li>MS/8</li></ul></li></ul><h5 id="1967年"><a href="#1967年" class="headerlink" title="1967年"></a>1967年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/ACP">ACP</a>（<a href="https://baike.baidu.com/item/IBM">IBM</a>）</li><li>CP/CMS</li><li><a href="https://baike.baidu.com/item/ITS">ITS</a></li><li>WAITS</li></ul></li></ul><h5 id="1969年"><a href="#1969年" class="headerlink" title="1969年"></a>1969年</h5><ul><li><ul><li>TENEX</li><li><a href="https://baike.baidu.com/item/Unix">Unix</a></li></ul></li></ul><h4 id="1970年代"><a href="#1970年代" class="headerlink" title="1970年代"></a>1970年代</h4><h5 id="1970年"><a href="#1970年" class="headerlink" title="1970年"></a>1970年</h5><ul><li><ul><li><p>DOS/BATCH 11（PDP-11）</p><p><a href="https://baike.baidu.com/item/1971%E5%B9%B4">1971年</a></p></li><li><p>OS/8</p></li></ul></li></ul><h5 id="1972年"><a href="#1972年" class="headerlink" title="1972年"></a>1972年</h5><ul><li><ul><li>MFT (operating system)</li><li><a href="https://baike.baidu.com/item/MVT">MVT</a></li><li>RDOS</li><li><a href="https://baike.baidu.com/item/SVS">SVS</a></li><li>VM/CMS</li></ul></li></ul><h5 id="1973年"><a href="#1973年" class="headerlink" title="1973年"></a>1973年</h5><ul><li><ul><li>Alto OS</li><li><a href="https://baike.baidu.com/item/RSX-11D">RSX-11D</a></li><li>RT-11</li><li><a href="https://baike.baidu.com/item/VME">VME</a></li></ul></li></ul><h5 id="1974年"><a href="#1974年" class="headerlink" title="1974年"></a>1974年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/MVS">MVS</a>（MVS/XA）</li></ul></li></ul><h5 id="1975年"><a href="#1975年" class="headerlink" title="1975年"></a>1975年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/BS2000">BS2000</a></li></ul></li></ul><h5 id="1976年"><a href="#1976年" class="headerlink" title="1976年"></a>1976年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/CP%2FM">CP/M</a></li><li>TOPS-20</li></ul></li></ul><h5 id="1978年"><a href="#1978年" class="headerlink" title="1978年"></a>1978年</h5><ul><li><ul><li>[Apple DOS 3.1](<a href="https://baike.baidu.com/item/Apple">https://baike.baidu.com/item/Apple</a> DOS 3.1)（<a href="https://baike.baidu.com/item/%E8%8B%B9%E6%9E%9C%E5%85%AC%E5%8F%B8">苹果公司</a>第一个操作系统）</li><li><a href="https://baike.baidu.com/item/TripOS">TripOS</a></li><li><a href="https://baike.baidu.com/item/VMS">VMS</a></li><li>Lisp Machine（CADR）</li></ul></li></ul><h5 id="1979年"><a href="#1979年" class="headerlink" title="1979年"></a>1979年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/POS">POS</a></li><li>NLTSS</li></ul></li></ul><h4 id="1980年代"><a href="#1980年代" class="headerlink" title="1980年代"></a>1980年代</h4><h5 id="1980年"><a href="#1980年" class="headerlink" title="1980年"></a>1980年</h5><ul><li><ul><li>OS-9</li><li><a href="https://baike.baidu.com/item/QDOS">QDOS</a></li><li><a href="https://baike.baidu.com/item/SOS">SOS</a></li><li>XDE (Tajo)</li><li><a href="https://baike.baidu.com/item/Xenix">Xenix</a></li></ul></li></ul><h5 id="1981年"><a href="#1981年" class="headerlink" title="1981年"></a>1981年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/MS-DOS">MS-DOS</a></li></ul></li></ul><h5 id="1982年"><a href="#1982年" class="headerlink" title="1982年"></a>1982年</h5><ul><li><ul><li>Commodore DOS</li><li><a href="https://baike.baidu.com/item/SunOS">SunOS</a>(1.0)</li><li>Ultrix</li></ul></li></ul><h5 id="1983年"><a href="#1983年" class="headerlink" title="1983年"></a>1983年</h5><ul><li><ul><li>Lisa OS</li><li><a href="https://baike.baidu.com/item/Coherent">Coherent</a></li><li>[Novell NetWare](<a href="https://baike.baidu.com/item/Novell">https://baike.baidu.com/item/Novell</a> NetWare)</li><li>ProDOS</li></ul></li><li></li></ul><h5 id="1984年"><a href="#1984年" class="headerlink" title="1984年"></a>1984年</h5><ul><li></li><li><ul><li>Macintosh OS（系统 1.0）</li><li>MSX-DOS</li><li><a href="https://baike.baidu.com/item/QNX">QNX</a></li><li>UniCOS</li></ul></li></ul><h5 id="1985年"><a href="#1985年" class="headerlink" title="1985年"></a>1985年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/AmigaOS">AmigaOS</a></li><li>Atari TOS</li><li>MIPS OS</li><li>Oberon operating system</li><li>Microsoft Windows 1.0（Windows第一版）</li></ul></li></ul><h5 id="1986年"><a href="#1986年" class="headerlink" title="1986年"></a>1986年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/AIX">AIX</a></li><li>GS-OS</li><li><a href="https://baike.baidu.com/item/HP-UX">HP-UX</a></li></ul></li></ul><h5 id="1987年"><a href="#1987年" class="headerlink" title="1987年"></a>1987年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/Arthur">Arthur</a></li><li><a href="https://baike.baidu.com/item/IRIX">IRIX</a>（SGI推出的第一个版本号是3.0）</li><li><a href="https://baike.baidu.com/item/Minix">Minix</a></li><li><a href="https://baike.baidu.com/item/OS%2F2">OS/2</a>（1.0）</li><li>Microsoft Windows 2.0</li></ul></li></ul><h5 id="1988年"><a href="#1988年" class="headerlink" title="1988年"></a>1988年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/A%2FUX">A/UX</a>（苹果电脑）</li><li><a href="https://baike.baidu.com/item/LynxOS">LynxOS</a></li><li>MVS/ESA</li><li>OS/400</li></ul></li></ul><h5 id="1989年"><a href="#1989年" class="headerlink" title="1989年"></a>1989年</h5><ul><li><ul><li><a href="https://baike.baidu.com/item/NeXTSTEP">NeXTSTEP</a>（1.0）</li><li>RISC OS</li><li>[SCO Unix](<a href="https://baike.baidu.com/item/SCO">https://baike.baidu.com/item/SCO</a> Unix)（第三版）</li></ul></li></ul><h4 id="1990年代"><a href="#1990年代" class="headerlink" title="1990年代"></a>1990年代</h4><h5 id="1990年"><a href="#1990年" class="headerlink" title="1990年"></a>1990年</h5><ul><li><ul><li>Amiga OS2.0</li><li><a href="https://baike.baidu.com/item/BeOS">BeOS</a>（v1）</li><li>OSF/1</li><li>Microsoft Windows 3.0</li></ul></li><li><p><a href="https://baike.baidu.com/item/1991%E5%B9%B4">1991年</a></p></li><li><ul><li><a href="https://baike.baidu.com/item/Linux">Linux</a></li></ul></li><li><p><a href="https://baike.baidu.com/item/1992%E5%B9%B4">1992年</a></p></li><li><ul><li><a href="https://baike.baidu.com/item/386BSD">386BSD</a>0.1</li><li>Amiga OS3.0</li><li><a href="https://baike.baidu.com/item/Solaris">Solaris</a>2.0 （SunOS 4.x的继承者，以SVR4为基础，而非BSD）</li><li>Microsoft Windows 3.1</li></ul></li><li><p><a href="https://baike.baidu.com/item/1993%E5%B9%B4">1993年</a></p></li><li><ul><li>九号项目（第一版）</li><li><a href="https://baike.baidu.com/item/FreeBSD">FreeBSD</a></li><li><a href="https://baike.baidu.com/item/NetBSD">NetBSD</a></li><li>Microsoft Windows NT 3.1（第一版NT）</li></ul></li><li><p><a href="https://baike.baidu.com/item/1995%E5%B9%B4">1995年</a></p></li><li><ul><li>Digital UNIX（<em>aka</em><a href="https://baike.baidu.com/item/Tru64">Tru64</a>）</li><li><a href="https://baike.baidu.com/item/OpenBSD">OpenBSD</a></li><li><a href="https://baike.baidu.com/item/OS%2F390">OS/390</a></li><li>Microsoft Windows 95</li></ul></li><li><p><a href="https://baike.baidu.com/item/1996%E5%B9%B4">1996年</a></p></li><li><ul><li>[Windows NT 4.0](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> NT 4.0)</li><li><a href="https://baike.baidu.com/item/Linux">Linux</a>2.0</li></ul></li><li><p><a href="https://baike.baidu.com/item/1997%E5%B9%B4">1997年</a></p></li><li><ul><li><a href="https://baike.baidu.com/item/Inferno">Inferno</a></li><li>Mac OS 7.6（第一版官方正式命名为Mac OS）</li><li><a href="https://baike.baidu.com/item/SkyOS">SkyOS</a></li></ul></li><li><p><a href="https://baike.baidu.com/item/1998%E5%B9%B4">1998年</a></p></li><li><ul><li><a href="https://baike.baidu.com/item/Solaris">Solaris</a>7 （第一款<a href="https://baike.baidu.com/item/64%E4%BD%8D">64位</a>Solaris版本，是2.7舍弃主版本号的称谓）</li><li>Microsoft Windows 98</li></ul></li><li><p><a href="https://baike.baidu.com/item/1999%E5%B9%B4">1999年</a></p></li><li><ul><li><a href="https://baike.baidu.com/item/AROS">AROS</a></li><li>Mac OS 8</li><li>Microsoft Windows 98 Second Edition</li></ul></li></ul><h4 id="2000年代"><a href="#2000年代" class="headerlink" title="2000年代"></a>2000年代</h4><ul><li><p><a href="https://baike.baidu.com/item/2000%E5%B9%B4">2000年</a></p></li><li><ul><li>AtheOS</li><li>[Mac OS 9](<a href="https://baike.baidu.com/item/Mac">https://baike.baidu.com/item/Mac</a> OS 9)</li><li>MorphOS</li><li>[Windows 2000](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> 2000)</li><li>Microsoft Windows Me</li></ul></li><li><p><a href="https://baike.baidu.com/item/2001%E5%B9%B4">2001年</a></p></li><li><ul><li>Amiga OS4.0 （2001年5月）</li><li>Mac OS X 10.1</li><li>[Windows XP](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> XP)</li><li><a href="https://baike.baidu.com/item/z%2FOS">z/OS</a></li></ul></li><li><p><a href="https://baike.baidu.com/item/2002%E5%B9%B4">2002年</a></p></li><li><ul><li>[Windows XP 64-bit Edition](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> XP 64-bit Edition)</li><li><a href="https://baike.baidu.com/item/Syllable">Syllable</a></li><li>Mac OS X 10.2</li></ul></li><li><p><a href="https://baike.baidu.com/item/2003%E5%B9%B4">2003年</a></p></li><li><ul><li>[Windows Server 2003](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> Server 2003)（2003年3月28日）</li><li>[Windows XP 64-bit Edition](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> XP 64-bit Edition)- 以Microsoft Windows Server 2003为基础，同一天发布。</li><li>Mac OS X 10.3</li></ul></li><li><p><a href="https://baike.baidu.com/item/2004%E5%B9%B4">2004年</a></p></li><li><ul><li>[Windows XP Media Center Edition](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> XP Media Center Edition)</li></ul></li><li><p><a href="https://baike.baidu.com/item/2005%E5%B9%B4">2005年</a></p></li><li><ul><li>[Windows XP Professional x64 Edition](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> XP Professional x64 Edition)</li><li>Mac OS X 10.4</li></ul></li><li><p><a href="https://baike.baidu.com/item/2006%E5%B9%B4">2006年</a></p></li><li><ul><li>Microsoft[Windows Vista](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> Vista)</li></ul></li><li><p><a href="https://baike.baidu.com/item/2007%E5%B9%B4">2007年</a></p></li><li><ul><li>Mac OS X 10.5</li></ul></li><li><p><a href="https://baike.baidu.com/item/2009%E5%B9%B4">2009年</a></p></li><li><ul><li>Mac OS X 10.6</li><li>Microsoft[Windows 7](<a href="https://baike.baidu.com/item/Windows">https://baike.baidu.com/item/Windows</a> 7)</li></ul></li></ul><h4 id="2010年代"><a href="#2010年代" class="headerlink" title="2010年代"></a>2010年代</h4><ul><li><p>2011年</p><p>——Mac OS X 10.7</p></li><li><p>2012年</p><p>——Windows 8</p><p>——Mac OS X 10.8</p></li><li><p>2013年</p><p>——Windows 8.1</p><p>——Mac OS X 10.9</p></li><li><p>2014年</p><p>——Mac OS X 10.10</p></li><li><p>2015年</p><p>——Windows 10</p><p>——Mac OS X 10.11</p></li><li><p>2016年</p><p>——Mac OS X 10.12</p></li><li><p>2017年</p><p>——Mac OS X 10.13</p></li><li><p>2018年</p><p>——Mac OS X 10.14</p></li><li><p>2019年</p><p>——Mac OS X 10.15</p></li></ul><hr><h3 id="第一代计算机的操作系统"><a href="#第一代计算机的操作系统" class="headerlink" title="第一代计算机的操作系统"></a>第一代计算机的操作系统</h3><h4 id="人工操作"><a href="#人工操作" class="headerlink" title="人工操作"></a>人工操作</h4><p>在第一台计算机上没有操作系统，对计算机的操作完全是人工操作方式（卡片打孔），这种操作方式有两个缺点：</p><ul><li>用户完全独占计算机，也就是说，及算你的全部资源直供一个用户使用。</li><li>计算机等待人工操作。当用户操作时计算机要等待CPU空闲</li></ul><hr><h3 id="第二代计算机的操作系统"><a href="#第二代计算机的操作系统" class="headerlink" title="第二代计算机的操作系统"></a>第二代计算机的操作系统</h3><h5 id="监控系统（dos）"><a href="#监控系统（dos）" class="headerlink" title="监控系统（dos）"></a>监控系统（dos）</h5><p>第二代计算机主要用于科学和工程计算，程序大多用FORTRAN语言书写，该语言适用于作数值运算，当时主机上用的控制程序称之为健康程序Monitor，其功能相对简单，监控程序是操作系统的雏形。</p><ul><li>单道批处理系统<ul><li>将所有的作业用一台相对比较便宜的计算机输入到磁带上，此计算机称为输入/输出机，实施数值运算、速度较快的计算机称为主机。大批的作业在输入/输出机的控制下输入到磁带后，用一个特殊的程序来控制作业的读入和运行，这个特殊的程序用作业控制语言（JCL，Job Control Language）书写，他能控制程序的运行。</li></ul></li></ul><hr><h3 id="操作系统的内部矛盾"><a href="#操作系统的内部矛盾" class="headerlink" title="操作系统的内部矛盾"></a>操作系统的内部矛盾</h3><ol><li>主机与外设速度的不匹配  Vcpu-Vp<ol><li>方案一，提供多台外设，以提高外设运算速度（产生多道程序设计—第三代计算机）</li><li>方案二，提高外设速度<ol><li>硬件方面—-使用 通道、中断技术（第三代计算机）</li><li>软件方面<ol><li>使用缓冲区技术（Buffer）</li><li>使用脱机输入/输出技术</li></ol></li></ol></li></ol></li><li>计算机与人速度的不匹配   Vcomputer-Vperson<ol><li>操作员方面—-对操作员进行分工 （第二代计算机开始分工）</li><li>减少干扰方面—-使用早期批处理技术<ol><li>作业控制卡</li><li>作业控制语言JCL</li><li>FORTRAN语言（第二代计算机开始）</li></ol></li><li>合作配合—-配备多个操作员，分时系统产生（第三代计算机开始）</li></ol></li></ol><h4 id="脱机输入-输出技术"><a href="#脱机输入-输出技术" class="headerlink" title="脱机输入/输出技术"></a>脱机输入/输出技术</h4><p>程序和数据的输入都不是在主机的控制之下，二十在一台专门输入、输出的计算机的控制之下进行，或者说，输入/输出工作是在脱离主机的情况之下进行的，故称为脱机输入/输出（OffLine I/O）</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200918110216.png"></p><hr><h3 id="操作系统的多元化发展"><a href="#操作系统的多元化发展" class="headerlink" title="操作系统的多元化发展"></a>操作系统的多元化发展</h3><ul><li>随着大规模集成电路（在每平方厘米的芯片上集成数千个晶体管）的发展，计算机向着微型化、网络化和智能化的方向发展。</li><li>个人计算机的时代到来。</li><li>个人计算机连成了网络。因此运行其上的网络操作系统和分布式操作系统就开始崛起。</li></ul><blockquote><p>安卓！=网路操作系统</p></blockquote><hr><h3 id="操作系统的发展与分类"><a href="#操作系统的发展与分类" class="headerlink" title="操作系统的发展与分类"></a>操作系统的发展与分类</h3><ol><li>成熟的系统<ol><li>批处理系统</li><li>分时系统</li><li>实时系统</li></ol></li><li>发展中的系统<ol><li>网络操作系统</li><li>分布式操作系统</li><li>个人操作系统</li><li>嵌入式操作系统</li><li>多处理机操作系统</li></ol></li></ol><h4 id="批处理操作系统"><a href="#批处理操作系统" class="headerlink" title="批处理操作系统"></a>批处理操作系统</h4><ol><li>批处理操作系统<ul><li>批处理操作系统（Batch Processing Operating System）的工作流程为：用户将作业交给操作人员，系统操作人员将多个用户的作业组成一批输入磁带，然后启动批处理操作系统。系统自动从磁带上加载作业到内存执行，最后把执行结果输出。</li><li>根据系统一次加载作业的道数，批处理操作系统分为单道批处理操作系统和多道批处理操作系统。<ul><li><strong>单道批处理操作系统</strong>每次只加载一道作业到内存中执行</li><li><strong>多道批处理操作系统</strong>每次加载多道作业到内存中并发执行，各个作业轮流使用处理机和其他系统资源，最终依次完成。</li></ul></li><li>批处理系统适合处理大批无交互的作业。</li></ul></li></ol><blockquote><p>运行程序经过三部分 </p><p>输入—-计算—-输出</p><p>这三部分称为交互</p><p>批处理不进行交互，直接使用作业控制语言（JCL）</p></blockquote><p>疑问1：批处理到内存中的指令优先级如何？</p><h5 id="多道批处理系统的特点"><a href="#多道批处理系统的特点" class="headerlink" title="多道批处理系统的特点"></a>多道批处理系统的特点</h5><blockquote><p>多道批处理系统的特点</p><ul><li>多道批处理系统中引入了<strong>多道程序设计技术</strong></li><li>基本思想：<ul><li>在内存中同时存放多道相互独立的程序，这些程序共享系统资源，并在操作系统的控制下交替在CPU上执行。</li></ul></li><li>特点：<ul><li>宏观上来看，内存中的多道程序都已经开始执行都尚未结束</li><li>微观上来看在单处理器系统中，某一个时刻只有一个程序获得CPU的执行</li></ul></li><li>多道程序交替执行的方式常称为程序的并发执行，采用多道程序设计技术的系统被称为多道程序系统。</li></ul></blockquote><h5 id="单道与多道程序"><a href="#单道与多道程序" class="headerlink" title="单道与多道程序"></a>单道与多道程序</h5><blockquote><p>单道与多道程序</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200918111922.png"></p><p>当一段程序执行时，系统发起了IO中断请求，cpu启动io监控程序，待io完成后，结束中断请求，继续执行程序</p></blockquote><h5 id="批处理系统的优缺点"><a href="#批处理系统的优缺点" class="headerlink" title="批处理系统的优缺点"></a>批处理系统的优缺点</h5><ul><li>批处理操作系统优点：作业逐批进入系统并逐批进行处理，系统资源利用率高、作业吞吐量大；作业之间的过渡由操作系统完成，无需人工干预，减少擦错的出现。</li><li>批处理操作系统的缺点：作业周转时间长；用户不能和正在执行的程序进行交互；不利于程序的开发和调试。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200918112437.png"></p><hr><h4 id="分时操作系统"><a href="#分时操作系统" class="headerlink" title="分时操作系统"></a>分时操作系统</h4><ul><li>分时操作系统是指将多个用户程序装入内存，系统把CPU的运行时间分成一个个的时间段，每个时间段称为一个时间片。时间片大小通常为几十毫秒，用户程序轮流获得CPU的时间片。当系统分给用户程序的时间片用完后，系统强行收回CPU，该用户程序等待下一次获得时间片时再继续执行。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200918123836.png"></p><ol><li>简单分时系统</li><li>具有前后台的分时系统</li><li>多道分时系统</li></ol><p>分时操作系统的特点</p><ul><li>同时性</li><li>交互性</li><li>独占性</li><li>及时性</li></ul><ul><li><p>时间片的选取：</p><p>过长会使终端用户不能及时得到响应，过短会造成CPU频繁切换，增大系统开销。操作系统设计者应对系统中的各种因素进行综合分析，选取适中的时间片。</p></li></ul><blockquote><p>CPU 切换时间片需要代价-时间</p></blockquote><p>​    </p><hr><h4 id="实时操作系统"><a href="#实时操作系统" class="headerlink" title="实时操作系统"></a>实时操作系统</h4><ul><li>所谓 “实时” ，即立即、及时的意思。实时操作系统能及时响应外部事件请求并在规定的时间内处理完毕。</li><li>实时任务按截止时间分为：<ol><li>硬实时任务</li><li>软实时任务</li></ol></li><li>实时操作系统为了保证系统能够及时、准确的做出响应，一般都具备实时时钟中断频率，实现精确计时，这可保证实时任务及时被执行。</li></ul><p>特殊要求</p><ol><li>高可靠性</li><li>过载保护</li><li>对截止时间的要求</li></ol><hr><h4 id="网络操作系统"><a href="#网络操作系统" class="headerlink" title="网络操作系统"></a>网络操作系统</h4><ul><li>网络OS模式<ul><li>客户/服务器模式   Client/server</li><li>对等模式  Peer to Peer</li></ul></li><li>网络OS功能<ul><li>网络通信</li><li>网络管理</li><li>资源共享管理</li><li>互操作能力</li><li>网络服务</li></ul></li></ul><hr><h4 id="分布式操作系统"><a href="#分布式操作系统" class="headerlink" title="分布式操作系统"></a>分布式操作系统</h4><p>分布式操作系统是由若干个计算机经互联网络连接而成的，这些计算机既可以独立工作，又能协同工作。可实现系统内的资源管理，任务动态分配，并能并行地运行分布式程序。</p><p>分布式OS特点</p><ul><li>多机合作</li><li>健壮性</li><li>透明性</li><li>共享性</li></ul><blockquote><p>分布式系统催生了区块链</p></blockquote><hr><h4 id="个人操作系统"><a href="#个人操作系统" class="headerlink" title="个人操作系统"></a>个人操作系统</h4><ul><li>个人操作系统是面向个人计算机应用而研制的一种操作系统。它是为没有计算机专业知识的个人计算机用户编写的、运行在个人计算机上的操作系统。</li><li>个人操作系统的特点主要有：<ol><li>具有良好的图形用户接口</li><li>管理性能较高，引入了许多过去在小型机中采用的技术如虚拟内存技术、多线程技术等</li><li>具有较好的可扩充性和兼容性，方便不同系统之间的互连和分布式处理</li><li>具有丰富的应用软件</li></ol></li></ul><hr><h3 id="操作系统的主要功能"><a href="#操作系统的主要功能" class="headerlink" title="操作系统的主要功能"></a>操作系统的主要功能</h3><ul><li>操作系统作为系统的资源管理者，并作为计算机和用户间的接口，它的主要功能如下：<ol><li>处理机管理</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>用户接口管理</li></ol></li></ul><blockquote><p>主要功能</p><ul><li>系统调用是操作系统提供服务的唯一途径。在最底层，系统调用允许运行程序直接向操作系统发出请求。</li><li>系统调用提供基本功能，如进程控制、文件操作和设备管理等。</li><li>操作系统中，由命令解释程序或系统程序来完成的高级别请求需要转换成一系列的系统请求。</li></ul></blockquote><h4 id="处理机管理功能"><a href="#处理机管理功能" class="headerlink" title="处理机管理功能"></a>处理机管理功能</h4><ul><li>操作系统采用的处理及管理策略决定了操作系统的主要性能。正是由于操作系统对处理机的管理策略的不同，其提供的作业处理方式也就不同。例如，批处理方式、分时处理方式、实时处理方式等。从而，呈现在用户面前，称为具有不同处理方式和不同特点的操作系统。</li></ul><blockquote><p>任务</p><ul><li>对处理及的分配和运行实施有效管理。</li><li>在多道程序环境下，处理及的分配和运行以进程为单位，因此对处理机的管理即对进程的管理。</li></ul></blockquote><blockquote><p>功能</p></blockquote><ul><li>进程控制</li><li>进程同步</li><li>进程通信</li><li>进程调度</li></ul><hr><h4 id="存储器管理功能"><a href="#存储器管理功能" class="headerlink" title="存储器管理功能"></a>存储器管理功能</h4><ul><li>由于内存容量有限，如何在内存中装入更多的并发执行进程以及如何运行比内存容量大得多的进程，这也是需要存储器管理解决的问题。操作系统通常采用虚拟存储技术来提高内存利用率和系统并发程度。如何保证内存中多道程序互不干扰，这也是内存管理的主要功能之一。</li></ul><blockquote><p>任务</p></blockquote><ul><li>方便用户使用内存</li><li><strong>提高内存的利用率</strong></li><li>从逻辑上扩充内存</li></ul><blockquote><p>功能</p></blockquote><ul><li>内存分配</li><li>地址映射</li><li>内存保护</li><li>内存扩充</li></ul><hr><h4 id="设备管理"><a href="#设备管理" class="headerlink" title="设备管理"></a>设备管理</h4><ul><li>计算机中所配置的I/O设备多种多样，他们的工作原理、I/O传输速度、传输方式千差万别。为了方便方便用户操作这些I/O设备，操作系统通常采用统一界面来管理I/O设备，使用户感觉不到差异。操作系统将I/O设备本身的物理特性差异交给设备驱动程序去处理，提高了其适应性。</li></ul><blockquote><p>任务</p></blockquote><ul><li>完成用户程序请求的I/O操作，为用户程序分配I/O设备</li><li>提高外部设备的利用</li><li>尽可能地提高输入/输出的速度</li><li>方便用户使用外部设备</li></ul><blockquote><p>功能</p></blockquote><ul><li>设备分配</li><li>设备控制</li><li>设备无关性</li></ul><hr><h4 id="文件管理"><a href="#文件管理" class="headerlink" title="文件管理"></a>文件管理</h4><ul><li><p>文件管理主要管理计算机系统中的信息资源。操作系统对用户文件和系统文件进行有效</p></li><li><p>的管理，有助于提高系统資源利用率和用户满意度。</p></li><li><p>操作系统的文件管理模块是最接近用户的部分，也是用户比较熟悉的部分。</p></li><li><p>现代计算机系统中，文件的存情介质主要是磁盘。不同的操作系统对文件的磁盘存储结</p></li><li><p>构有不同的组织方式，文件在磁盘上以何种结构进行组织和存放直接影响文件存取速度。</p></li></ul><blockquote><p>任务</p></blockquote><ul><li>大量的信息以文件的形式放在外存，对信息的管理也就是对文件的管理。</li></ul><blockquote><p>功能</p></blockquote><ul><li>文件存储空间的管理</li><li>目录管理</li><li>文件的读、写管理</li><li>文件的存取控制</li></ul><hr><h4 id="用户接口管理功能"><a href="#用户接口管理功能" class="headerlink" title="用户接口管理功能"></a>用户接口管理功能</h4><ul><li>操作系统向用户提供了各种使用接口：<ul><li>命令接口：<ul><li>联机命令接口</li><li>脱机命令接口</li><li>图形用户界面（命令接口的改版）</li></ul></li><li>程序接口 也称系统调用</li></ul></li></ul><hr><h3 id="操作系统的主要特征"><a href="#操作系统的主要特征" class="headerlink" title="操作系统的主要特征"></a>操作系统的主要特征</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200926170350.png"></p><h4 id="并发执行"><a href="#并发执行" class="headerlink" title="并发执行"></a>并发执行</h4><p>并发性是指两个或多个事件在同一时间间隔内发生。因为有了并发性，内存中可同时存放操作系统程序和若干个用户程序，各个程序轮流切换地使用CPU</p><p><strong>区分两个概念:并发和并行</strong></p><p>若在一个时间段内发生了一个以上的事件，则称这几个事件具有并发性而并行性指的是多个事件在同一时刻点发生</p><p>并发性能有效地提高系统资源利用率和作业吞吐率。并发性同时也给操作系统带来了系列问题，使操作系统的设计和实现变得异常复杂。</p><p><strong>并行强调同时，并发强调切换</strong></p><hr><h4 id="资源共享"><a href="#资源共享" class="headerlink" title="资源共享"></a>资源共享</h4><ul><li>操作系统中的共享，指的是多个并发执行的程序按照一走的规则共同使用操作系统所管理的软硬件资源。</li><li>操作系统所管理的软硬件资源按照使用方式可分为：<ul><li>同时访问方式（同时型共享）</li><li>互斥访问方式（互斥型共享）</li></ul></li><li>共享性和并发性相辅相成。由于并发所以实现了资源共享，但一味追求共享，管理不好就会影响并发性的实现，甚至会导致进程的运行结果错误。这些内容在后续章节中会有详细讲解</li></ul><hr><h4 id="一切皆虚拟"><a href="#一切皆虚拟" class="headerlink" title="一切皆虚拟"></a>一切皆虚拟</h4><p>虚拟”的概念在操作系统中随处可见。操作系统中的“虚拟″是指通过某种管理技术把一个物理实体变为若千个逻辑上的对应物，或把物理上的多个实体变成逻辑上的一个对应物。物理实体是客观存在的，逻辑上的对应物是虚构的，只是用户主观上的一种想象</p><p>现代操作系统中主要有两种虚拟技术:时分复用技术和空分复用技术</p><p>1）时分复用技术，即分时使用技术。把硬件设备的使用时间分割成小的时间片，供多个用户程序“轮流”、“切换”使用。</p><p>2）空分复用技术，即通过空间的划分，把一个物理存储设备改造成为逻辑上的多个存储设备。</p><ul><li>工作模式不同的各个设备所使用的映射方法不同。<ul><li>虚拟存储器技术</li><li>虚拟处理器技术</li><li>虚拟设备技术</li></ul></li><li>虚拟特性的实现主要依靠分时共享和多道程序设计技术，在它们的帮助下，操作系统可以将一个设备映射为多个，将一个设备的能力均分到不同的逻辑设备上，以便多用户共享资源。</li><li>虚拟方法不会造成多个用户长期等待他用户操作完成，同时能够极大地提高資源利用率。</li></ul><hr><h4 id="异步性"><a href="#异步性" class="headerlink" title="异步性"></a>异步性</h4><ul><li>异步性指在多道程序设计环境下，系统中每道程序的推进时间、顺序以及完成时间由于受其运行环境的影响是不确定的、不可预知的。程序的执行是以“走走停停”的方式运行</li><li>有的文献也称异步性为不确定性、随机性。</li><li>例:两个程序共享一个全局变量N，程序A中设N=5;程序B中设N=3，并打印N。A和B并发执行，可能会出现以下3种情况:<ul><li>先执行A，再执行B，打印语句在N=5与N=3后执行，打印结果为3</li><li>先执行N=3，然后切换执行A，打印语句在N=5之后执行，打印结果为5</li><li>先执行B，再执行A，打印结果为3。</li></ul></li></ul><blockquote><p>答疑：操作系统中的异步是程序设计中异步的基础，程序设计中采取了某种方式使得操作系统中的异步获得确定性，二者相同的地方在于单纯讨论异步这个操作，从宏观上来说他是同时进行的，从微观上来说他实际上是类似分时操作系统中切片的机制交替执行的</p></blockquote><ul><li>异步性的产生是由现代操作系统的并发性引起的。<ul><li>在并发执行的多个进程间，何时能够获得所需资源，在什么时刻等待哪些进程放資源，以及当前占有資源的进程何时释放资源等因素都是不确定的，因此用户是无法预知各个进程的执行时间</li></ul></li><li>异步性增加了操作系统的设计与实现难度，操作系统设计者必须采取一定的措施保证系统不出现结果随机性</li></ul><hr><h3 id="操作系统的结构"><a href="#操作系统的结构" class="headerlink" title="操作系统的结构"></a>操作系统的结构</h3><ul><li>使用软件工程思想设计操作系统时，除了要满足操作系统的基本设计目标外，还要根据用户需求分析采用哪种形式的操作系统结构更适用。</li><li>较有代表性的OS结构<ul><li>无结构操作系统</li><li>模块化结构操作系统</li><li>分层式结构操作系统</li><li>虚拟机結结构操作系统</li><li>微内核结构操作系統（客户/服务器模型）</li></ul></li></ul><hr><h4 id="模块化结构操作系统"><a href="#模块化结构操作系统" class="headerlink" title="模块化结构操作系统"></a>模块化结构操作系统</h4><ul><li>模块化结构又称为整体结构，它采用结构化程序设计技术，将复杂的OS需求分解后根据相关性分类，毎个类别使用一个或几个模块实现。</li><li>模块-接口法:整体结构OS的各模块分别具有特定管理功能，且相互之间使用规定好的接口通信。各模块进一步划分为子模块和通信接口。子模块还可以进一步细分为更小的模块</li></ul><p><strong>特点</strong></p><ul><li>内娶度低;耦合度高</li><li>新加入的系统功能可以独立设计、编码和调试后再与原系统连接形成新的整体</li><li>各模块独立开发，缩短系统开发周期</li><li>独立开发的各模块无法基于确定前趋模块完成，这种无序性将会导致设计的基础无法保证可靠</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200926171645.png"></p><hr><h4 id="分层式结构操作系统"><a href="#分层式结构操作系统" class="headerlink" title="分层式结构操作系统"></a>分层式结构操作系统</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200926171727.png"></p><ul><li>便于保证系统正确性</li><li>便于进行功能扩充和系统维护</li><li>各层间都要定义通信机制，这样当一个用户请求需要使用较低层次的功能时，需要多次穿越层边界，这样的做法会增加通信开销，导致系统效率降低</li></ul><hr><h4 id="虚拟机结构操作系统"><a href="#虚拟机结构操作系统" class="headerlink" title="虚拟机结构操作系统"></a>虚拟机结构操作系统</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200926171840.png"></p><hr><h4 id="微内核结构操作系统"><a href="#微内核结构操作系统" class="headerlink" title="微内核结构操作系统"></a>微内核结构操作系统</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200926171909.png"></p><ul><li>数据可以分布式处理和存储</li><li>重要数据可放在受到严密保护的服务器所在的局域网内，便于集中管理，以保证数据安全</li><li>C/S结构有较好的灵活性和可扩充性</li><li>易于修改用户程序</li></ul><hr><h3 id="操作系统的运行环境"><a href="#操作系统的运行环境" class="headerlink" title="操作系统的运行环境"></a>操作系统的运行环境</h3><h4 id="时钟"><a href="#时钟" class="headerlink" title="时钟"></a><strong>时钟</strong></h4><ul><li>为了让计算机的各项操作功能在不同时间段有序、分布完成，计算机必须提供系统时钟。系统时钟通常安装在主机板上，像节拍器一样规律性地控制计算机工作</li><li>系统时钟通常分为两种控制方式:同步时序控制方式和异步时序控制方式。</li></ul><h4 id="处理机状态及状态转换"><a href="#处理机状态及状态转换" class="headerlink" title="处理机状态及状态转换"></a>处理机状态及状态转换</h4><ul><li>计算机系统根据运行程序对资源和机器指令的使用权限把处理机的执行状态分成两类。<ul><li>核心态（又称为管态、待权状态、系统模式）</li></ul></li><li>核心态是指操作系统运行时，处理机所处的状态。处理机处于核心态时，其上运行的程序可以执行包括特权指令和非特权指令在内的全部机器指令，能访问所有系统資源并具有改变处理机状态的能力。<ul><li>用户态（又称目态、目标状态用户模式</li></ul></li><li>用户态是指用户程序运行时处理机所处的状态。处理机处于用户态时只能执行硬件机器指令的一个子集，即非特权指令。</li></ul><h4 id="特权指令和非特权指令"><a href="#特权指令和非特权指令" class="headerlink" title="特权指令和非特权指令"></a>特权指令和非特权指令</h4><ul><li>待权指令是只能在核心态下执行的指令，这些指令的执行不但能影响程序本身，还会影响其他程序甚至整个操作系统。例如:启动物理设备指令、设置时钟中断指令、控制中断屏蔽指令、存储保护指令等。</li><li>非待权指令是在核心态和用户态下都能执行的指令，这些指令的执行只与运行程序本身有关，不会影响其他程序。例如:数据传送指令、图形显示指令等。</li><li>操作系统能使用特权指令和非特权指令，用户程序只能使用非特权指令。若用户程序直接使用特权指令，可能引起系统冲突或由于某些意外造成系统错误，威胁系统安全</li></ul><h4 id="控制和状态寄存器"><a href="#控制和状态寄存器" class="headerlink" title="控制和状态寄存器"></a>控制和状态寄存器</h4><p>程序状态字（PSW）寄存器</p><blockquote><p>程序状态字用来指示处理机状态、控制指令执行顺序并保留与运行程序有关的各种信息，其主要作用是实现程序状态的保护和恢复。每个正在执行的程序都有一个与其执行相关的程序状态字，处理机通过读取程序状态字知道当前处于用户态还是处于核心</p></blockquote><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200926172422.png"></p><hr><h4 id="程序状态字"><a href="#程序状态字" class="headerlink" title="程序状态字"></a>程序状态字</h4><p><strong>程序计数器PC</strong></p><ul><li>程序计数器存放要执行的下一条指令的地址。它可指出内存的任一地址,其宽度与内存的单元个数相对应,通常与内存的地址寄存器位数相等。</li><li>在程序执行过程中,CPU将自动修改PC的内容,顺序执行时为PC+1。程序跳转执行时,PC将被置入跳转执行所含的转移地址,使其保持的总是将要执行的下一条指令的地址,从而使程序能连续自动地执行下去,直至结束。</li></ul><hr><h4 id="中断和异常"><a href="#中断和异常" class="headerlink" title="中断和异常"></a>中断和异常</h4><p>中断</p><ul><li>现代计算机都配置了硬件中断装置，他们是计算机系统的重要组成部分。</li><li>中断指计算机系统为应对突发事件而采取的处理措施</li><li>在进程执行过程中，若遇到某个突发事件，处理机及时利用设定好的中断机制中断当前真正执行的进程，保存好中断现场，继续执行中断进程</li><li>当中断处理完后，恢复进程的中断现场，继续中断进程。</li></ul><blockquote><p>如，某进程从磁带读入一组信息，读入信息有误时，产生数据错误中断，操作系统暂停当前工作，组织磁盘退回，重读该组信息。这可解决错误，得到正确磁盘信息。</p></blockquote><ul><li>中断给操作系统设计带来许多好处，首先使得实时处理许多紧急事件成为可能；再者，中断可以增加处理及的执行效率；另外，中断还可以简化操作系统的程序设计。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200926174433.png"></p><p>异常</p><p>异常是由cpu执行指令的某种特殊结果而引发的中断</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200926174528.png"></p><p>中断和异常比较必有一下明显特征：</p><ol><li>异常由cpu内部产生，在单处理机的计算机系统中不会同时发生多个异常。</li><li>除页面例外和硬件异常之处，通常不会发生异常的嵌套，即不会在执行异常处理程序的过程中又发生新的异常。</li><li>异常不能被屏蔽。异常必须被及时处理，否则无法继续正常运行。</li></ol><blockquote><p>疑问1：这里的异常与程序设计中的异常有何异同，程序抛出异常可以正常运行</p></blockquote><hr><h4 id="地址映射机构"><a href="#地址映射机构" class="headerlink" title="地址映射机构"></a>地址映射机构</h4><ol><li>用户程序多由高级语言编写，程序中的地址一般从0开始。由于程序中的地址不是内存实际地址，程序不能被处理及直接执行。</li><li>用户程序需要线通过编译程序编译或汇编程序汇编后获得目标程序，目标程序中的地址也不是内存实际地址，通常被称为逻辑地址。逻辑地址的集合称为该用户程序的逻辑地址空间，逻辑地址空间可是从0开始排序的一维地址，也可是二维地址。</li><li>当程序运行时被装入内存，程序和数据的内存地址一般不与原来的逻辑地址一致，在多道程序系统中，内存中同时存放多个程序，每个程序在内存中的存放位置是随机的，且可以更改。</li><li>操作系统通常是要使用硬件系统中的地址映射机构进行地址变换，保证用户程序放入内存后仍能正确找到并执行完毕。</li></ol><hr><h4 id="通道与DMA控制器"><a href="#通道与DMA控制器" class="headerlink" title="通道与DMA控制器"></a>通道与DMA控制器</h4><p>为把CPU从繁琐的I/0操作中解脱出来,增加CPU与I/0设备、I/0设备与I/0设备之间的并行程度,一般采取的方法是利用硬件系统提供的DMA( Direct Memory Access直接内存访问)控制器或通道专门负责I/0设备操作,CPU只发送I/0指令。在I/0设备工作期间,CPU可去做其他工作。I/设备在DMA控制器或通道的控制下进行I/0操作,只在I/0操作结束后或出现异常时才向CPU发出中断请求,否则I/0设备和CPU并行工作,两者的利用率都得到了极大提高。</p><p><strong>通道</strong></p><p>通道是专门负责I/O操作的处理及，具有自己的简单指令系统，但一般没有自己的内存，通常和cpu共用系统内存。通道可执行由通道指令组成的通道程序，控制I.O设备和内存之间一次传递一组数据块，传递期间不需cpu干预，DMA控制器与通道类似，但功能相对简单一些，没有自己专用的指令系统，一次只能控制I/O设备和内存之间传输一个数据块。</p><hr><h4 id="陷入"><a href="#陷入" class="headerlink" title="陷入"></a>陷入</h4><ul><li>陷入（Trap）指cpu指向性一条实现系统调用的 陷入指令或执行指令时出现异常情况，如是算术溢出等系统中断当前进程的执行，去执行相应的陷入处理程序或异常处理程序。</li><li>陷入指令是为了实现用户程序调用系统内核程序。用户或者系统实用程序在cpu上执行时，如想请求操作系统为其提供某种服务，可安排其执行一条陷入指令，陷入的处理一般依赖于当前进程的执行现场，且陷入不能被屏蔽一旦出现陷入，立即处理。陷入指令是一种特殊的程序调用，<strong>其特殊之处在于处理及状态从用户态变成核心态</strong></li></ul><hr><h4 id="与其他系统软件关系"><a href="#与其他系统软件关系" class="headerlink" title="与其他系统软件关系"></a>与其他系统软件关系</h4><ul><li>系统软件直接服务于计算机系统，通常由计算机厂商或专业软件开发商提供。它包含指导计算机基本操作的程序，如屏幕显示程序、磁盘存储程序、向打印机发送数据程序、解释用户命令程序以及和外围设备通讯程序等。系统软件使用户更加方便地操作操作系统，控制系统资源按照操作系统的要求运行。</li><li>操作系统是直接与硬件相邻的第一层软件，它由大量系统程序和众多数据结构集成。操作系统不但控制和管理着其他各种系统软件，而且与其他系统软件共同支撑用户程序的运行，操作系统是在系统中永久运行的超级系统软件。</li><li>操作系统虽是一种系统软件.但它是系统软件中的系统软件。没有它的支持，其他系统软件都不能运行。同时,操作系统的功能设计也受其他系统软件功能强弱和完备与否的影响，没有完备的系统软件与应用软件的支持，操作系统也不会得到广大用户的认可。</li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200926180815.png"></p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker</title>
      <link href="/2020/08/31/docker/"/>
      <url>/2020/08/31/docker/</url>
      
        <content type="html"><![CDATA[<figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker pull mysql<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs powershell">docker run <span class="hljs-literal">-p</span> <span class="hljs-number">3306</span>:<span class="hljs-number">3306</span> -<span class="hljs-literal">-name</span> mysql  <span class="hljs-literal">-v</span> E:\docker\mysql:/var/lib/mysq <span class="hljs-literal">-v</span> E:\docker\mysqlConfig:/etc/mysql/conf.d <span class="hljs-literal">-e</span> MYSQL_ROOT_PASSWORD=<span class="hljs-number">123456</span> <span class="hljs-literal">-d</span> mysql<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs shell">docker port # 查看映射端口对应的容器内部源端口<br>docker pause # 暂停容器<br>docker ps # 猎户容器列表<br>docker pull # 从docker镜像源服务器拉取指定镜像或者库镜像<br>docker push # 推送指定镜像或者库镜像至docker源服务器<br>docker restart # 重启运行的容器<br>docker rm # 移除一个或多个容器<br>docker rmi # 移除一个或多个镜像 （无容器使用该镜像才可删除，否则需要删除相关容器才可继续或 -f 强制删除）<br>docker run # 创建一个新的容器并运行一个命令<br>docker save # 保存一个镜像为一个 tar 包【对应 load】<br>docker search # 在 docker hub 中搜索镜像<br>docker start # 启动容器<br>docker stop # 停止容器<br>docker tag # 给源中镜像打标签<br>docker top # 查看容器中运行的进程信息<br>docker unpause # 取消暂停容器<br>docker version # 查看 docker版本号<br>docker wait # 截取容器停止时的退出状态值<br></code></pre></td></tr></table></figure><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs powershell">attach <span class="hljs-comment"># 当前shell下attach连接指定运行镜像</span><br>build <span class="hljs-comment"># 通过Dockerfile定制镜像</span><br>commit <span class="hljs-comment"># 提交当前容器为新的镜像</span><br><span class="hljs-built_in">cp</span> <span class="hljs-comment"># 从容器中拷贝指定文件或目录到宿主机中</span><br>create <span class="hljs-comment"># 创建一个新的容器，同 run 但不启动容器</span><br><span class="hljs-built_in">diff</span> <span class="hljs-comment"># 查看 docker 容器变化</span><br>events <span class="hljs-comment"># 从docker服务器获取容器实时事件</span><br>exec <span class="hljs-comment"># 在已存在的容器上运行命令</span><br>export <span class="hljs-comment"># 导出容器的内容流作为一个 tar 归档文件【对应 import】</span><br><span class="hljs-built_in">history</span> <span class="hljs-comment"># 展示一个镜像形成历史</span><br>images <span class="hljs-comment"># 列出系统当前镜像</span><br>import <span class="hljs-comment"># 从tar包中的内容创建一个新的文件系统映像【对应 export】</span><br>info <span class="hljs-comment"># 显示系统相关信息</span><br>inspect <span class="hljs-comment"># 查看容器详细信息</span><br><span class="hljs-built_in">kill</span> <span class="hljs-comment"># kill 指定的容器</span><br>load <span class="hljs-comment"># 从一个 tar 包中加载一个镜像【对应 save】</span><br>login <span class="hljs-comment"># 注册或者登录一个 docker 源服务器</span><br>logout <span class="hljs-comment"># 从当前 Docekr registry 退出</span><br>logs <span class="hljs-comment"># 输出当前容器日志信息</span><br></code></pre></td></tr></table></figure><p>待更</p>]]></content>
      
      
      <categories>
          
          <category> docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shiro+jwt</title>
      <link href="/2020/08/28/jwt+shiro/"/>
      <url>/2020/08/28/jwt+shiro/</url>
      
        <content type="html"><![CDATA[<p>待更</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合shiro</title>
      <link href="/2020/08/28/jwt/"/>
      <url>/2020/08/28/jwt/</url>
      
        <content type="html"><![CDATA[<p>待更</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>springboot整合jwt</title>
      <link href="/2020/08/28/shiro/"/>
      <url>/2020/08/28/shiro/</url>
      
        <content type="html"><![CDATA[<p>待更</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vue-element-admin</title>
      <link href="/2020/08/28/vue-eletment-admin/"/>
      <url>/2020/08/28/vue-eletment-admin/</url>
      
        <content type="html"><![CDATA[<h1 id="vue-element-admin"><a href="#vue-element-admin" class="headerlink" title="vue-element-admin"></a><a href="https://panjiachen.gitee.io/vue-element-admin-site/zh/">vue-element-admin</a></h1><h1 id="登录成功-但发生请求但-Shiro-判断为未登录"><a href="#登录成功-但发生请求但-Shiro-判断为未登录" class="headerlink" title="登录成功 但发生请求但 Shiro 判断为未登录"></a>登录成功 但发生请求但 Shiro 判断为未登录</h1><p>前端使用vue-element-admin  </p><p>后端采用spring shiro jwt</p><p>前端登录成功返回token，但当通过shiro的权限判断时，</p><p>被factoryBean.setLoginUrl(“/Service/unlogin”); 重定向到未登录。</p><p>页面跳转时应该请求头带上 cookie</p><p>vue-element-admin  默认不发送cookie </p><p>找到request.js并</p><p>启动 withCredentials: true  即可</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> service = axios.create(&#123;<br>  baseURL: process.env.VUE_APP_BASE_API, <span class="hljs-comment">// url = base url + request url</span><br>  withCredentials: <span class="hljs-literal">true</span>, <span class="hljs-comment">// send cookies when cross-domain requests</span><br>  timeout: <span class="hljs-number">5000</span> <span class="hljs-comment">// request timeout</span><br>&#125;)<br></code></pre></td></tr></table></figure><hr><h1 id="响应中的“Access-Control-Allow-origin”头的值不能是通配符“-”"><a href="#响应中的“Access-Control-Allow-origin”头的值不能是通配符“-”" class="headerlink" title="响应中的“Access Control Allow origin”头的值不能是通配符“*”"></a>响应中的“Access Control Allow origin”头的值不能是通配符“*”</h1><p>vue报错信息之跨域当请求的凭据模式为“include”时，响应中的“Access Control Allow origin”头的值不能是通配符“*”</p><p>CORS策略已阻止从源位置“<a href="http://localhost:3000/api/index/getNotice%E2%80%9D%E8%AE%BF%E9%97%AEXMLHttpRequest:http://localhost:8080%E2%80%9D%EF%BC%9A%E5%BD%93%E8%AF%B7%E6%B1%82%E7%9A%84%E5%87%AD%E6%8D%AE%E6%A8%A1%E5%BC%8F%E4%B8%BA%E2%80%9Cinclude%E2%80%9D%E6%97%B6%EF%BC%8C%E5%93%8D%E5%BA%94%E4%B8%AD%E7%9A%84%E2%80%9CAccess">http://localhost:3000/api/index/getNotice”访问XMLHttpRequest:http://localhost:8080”：当请求的凭据模式为“include”时，响应中的“Access</a> Control Allow origin”头的值不能是通配符“*”。XMLHttpRequest启动的请求的凭据模式由withCredentials属性控制。</p><p>这样的结果可能是你在前端开启了withCredentials影响的，这时后台要添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">response.setHeader(&quot;Access-Control-Allow-Origin&quot;,&quot;Origin地址 如 http:&#x2F;&#x2F;localhost:9528&quot;);<br>response.setHeader(&quot;Access-Control-Allow-Credentials&quot;,&quot;true&quot;);<br></code></pre></td></tr></table></figure><hr><h1 id="Added-non-passive-event-listener-to-a-scroll-blocking-‘mousewheel’-event-告警"><a href="#Added-non-passive-event-listener-to-a-scroll-blocking-‘mousewheel’-event-告警" class="headerlink" title="Added non-passive event listener to a scroll-blocking ‘mousewheel’ event.告警"></a>Added non-passive event listener to a scroll-blocking ‘mousewheel’ event.告警</h1><h2 id="原因："><a href="#原因：" class="headerlink" title="原因："></a>原因：</h2><p>详解：<a href="https://www.cnblogs.com/PopularProdigal/p/8005783.html">https://www.cnblogs.com/PopularProdigal/p/8005783.html</a><br>Chrome51 版本以后，Chrome 增加了新的事件捕获机制－Passive Event Listeners。<br>Passive Event Listeners：就是告诉前页面内的事件监听器内部是否会调用preventDefault函数来阻止事件的默认行为，以便浏览器根据这个信息更好地做出决策来优化页面性能。当属性passive的值为true的时候，代表该监听器内部不会调用preventDefault函数来阻止默认滑动行为，Chrome浏览器称这类型的监听器为被动（passive）监听器。目前Chrome主要利用该特性来优化页面的滑动性能，所以Passive Event Listeners特性当前仅支持mousewheel/touch相关事件。</p><h2 id="解决方法："><a href="#解决方法：" class="headerlink" title="解决方法："></a>解决方法：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs plain">1、npm i default-passive-events -S<br>2、main.js中加入：import &#39;default-passive-events&#39;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u010622874/article/details/104396342">https://blog.csdn.net/u010622874/article/details/104396342</a></p><hr><h1 id="端口跨域方案1-前端解决"><a href="#端口跨域方案1-前端解决" class="headerlink" title="端口跨域方案1   前端解决"></a>端口跨域方案1   前端解决</h1><p>vue.config.js中添加代理</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js">proxy: &#123;<br>  [process.env.VUE_APP_BASE_API]: &#123;<br>    target: <span class="hljs-string">&#x27;http://localhost:8082&#x27;</span>, <span class="hljs-comment">// 要请求的地址</span><br>    ws: <span class="hljs-literal">true</span>,<br>    changeOrigin: <span class="hljs-literal">true</span>,<br>    pathRewrite: &#123;<br>      [<span class="hljs-string">&#x27;^&#x27;</span>+process.env.VUE_APP_BASE_API]: <span class="hljs-string">&#x27;&#x27;</span><br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>.env.development中 设置VUE_APP_BASE_API为空</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs js">VUE_APP_BASE_API = <span class="hljs-string">&#x27;&#x27;</span><br></code></pre></td></tr></table></figure><hr><h1 id="端口跨域2-后端解决"><a href="#端口跨域2-后端解决" class="headerlink" title="端口跨域2 后端解决"></a>端口跨域2 后端解决</h1><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><p>springboot中</p><p>添加注解@CrossOrigin</p><h2 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h2><p>WEBMvcConfigurer扩展类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean <span class="hljs-title">filterRegistrationBean</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 对响应头进行CORS授权</span><br>    MyCorsRegistration corsRegistration = <span class="hljs-keyword">new</span> MyCorsRegistration(<span class="hljs-string">&quot;/**&quot;</span>);<br>    corsRegistration.allowedOrigins(<span class="hljs-string">&quot;*&quot;</span>)<br>            .allowedMethods(HttpMethod.GET.name(), HttpMethod.HEAD.name(), HttpMethod.POST.name(),<br>                    HttpMethod.PUT.name(), HttpMethod.OPTIONS.name())<br>            .allowedHeaders(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;Origin&quot;</span>, <span class="hljs-string">&quot;X-Requested-With&quot;</span>, <span class="hljs-string">&quot;Content-Type&quot;</span>,<br>                    <span class="hljs-string">&quot;Last-Modified&quot;</span>, <span class="hljs-string">&quot;device&quot;</span>, <span class="hljs-string">&quot;token&quot;</span>)<br>            .exposedHeaders(HttpHeaders.SET_COOKIE)<br>            .allowCredentials(<span class="hljs-keyword">true</span>)<br>            .maxAge(<span class="hljs-number">3600</span>);<br><br>    <span class="hljs-comment">// 注册CORS过滤器</span><br>    UrlBasedCorsConfigurationSource configurationSource = <span class="hljs-keyword">new</span> UrlBasedCorsConfigurationSource();<br>    configurationSource.registerCorsConfiguration(<span class="hljs-string">&quot;/**&quot;</span>, corsRegistration.getCorsConfiguration());<br>    CorsFilter corsFilter = <span class="hljs-keyword">new</span> CorsFilter(configurationSource);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FilterRegistrationBean(corsFilter);<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs plain">import org.springframework.web.cors.CorsConfiguration;<br>import org.springframework.web.servlet.config.annotation.CorsRegistration;<br><br>&#x2F;**<br> * &lt;p&gt;<br> * kuayu<br> * &lt;&#x2F;p&gt;<br> *<br> * @author 等什么柠檬君<br> * @since 2020&#x2F;8&#x2F;28<br> *&#x2F;<br>public class MyCorsRegistration extends CorsRegistration &#123;<br><br><br><br>    public MyCorsRegistration(String pathPattern) &#123;<br>        super(pathPattern);<br>    &#125;<br><br><br>    @Override<br>    public CorsConfiguration getCorsConfiguration() &#123;<br>        return super.getCorsConfiguration();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="jwt拦截器"><a href="#jwt拦截器" class="headerlink" title="jwt拦截器"></a>jwt拦截器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">preHandle中添加<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Headers&quot;</span>, <span class="hljs-string">&quot;*&quot;</span>);<br>response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Origin&quot;</span>,<span class="hljs-string">&quot;*&quot;</span>);<br>response.setHeader(<span class="hljs-string">&quot;Access-Control-Allow-Credentials&quot;</span>,<span class="hljs-string">&quot;true&quot;</span>);<br>response.setCharacterEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>response.setContentType(<span class="hljs-string">&quot;application/json&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐心步数助手服务端</title>
      <link href="/2020/08/22/%E4%B9%90%E5%BF%83%E6%AD%A5%E6%95%B0%E5%8A%A9%E6%89%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF/"/>
      <url>/2020/08/22/%E4%B9%90%E5%BF%83%E6%AD%A5%E6%95%B0%E5%8A%A9%E6%89%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h1><p>此处以宝塔面板做演示</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822151158.png"></p><p>进入站点根目录，上传jar包，等待上传完成</p><h1 id="创建数据库"><a href="#创建数据库" class="headerlink" title="创建数据库"></a>创建数据库</h1><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822151526.png"></p><p>创建名为 <code>mysteps</code> 的数据库</p><p>用户名设置为 <code>mystep</code></p><p>密码设置为 <code>root</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822151618.png"></p><p>进入管理</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822151650.png"></p><p>mysteps—&gt;导入—&gt;选择文件导入mysteps.sql—&gt;点击执行</p><p>数据库导入完成</p><h1 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h1><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822152901.png"></p><p>进入终端，进入站点根目录。即文件上传目录</p><p>输入以下命令启动服务，若你想保持前台运行 输入java -jar StepService.jar</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar StepService.jar &amp;<br></code></pre></td></tr></table></figure><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822163857.png"></p><p>如图所示表示启动成功</p><p>若出现8080端口占用情况如下</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">***************************<br>APPLICATION FAILED TO START<br>***************************<br><br>Description:<br><br>Web server failed to start. Port 8080 was already <span class="hljs-keyword">in</span> use.<br><br>Action:<br><br>Identify and stop the process that<span class="hljs-string">&#x27;s listening on port 8080 or configure this application to listenon another port.</span><br></code></pre></td></tr></table></figure><p>需停止占用端口的应用 方法如下</p><ol><li><p>netstat -lnp|grep 80</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822153434.png"></p></li><li><p>kill -9 12095</p></li><li><p>netstat -lnp|grep 80</p><p>然后重新 使用 java -jar StepService.jar &amp; 运行服务</p></li></ol><hr><h1 id="接口文档"><a href="#接口文档" class="headerlink" title="接口文档"></a>接口文档</h1><p>参数说明：</p><p>phone        手机号</p><p>password  密码</p><p>steps          提交的步数</p><p>flag             是否开启自动刷步   0为不自动刷步  1为自动刷步   刷步时间为每日中午12点</p><h2 id="单次提交步数"><a href="#单次提交步数" class="headerlink" title="单次提交步数"></a>单次提交步数</h2><p>get请求 </p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://你的域名(或者公网ip:8080)/Service/updateStep?phone=18888888888&amp;password=CZ123456&amp;steps=9990&amp;flag=0<br></code></pre></td></tr></table></figure><p>响应 </p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;成功&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;pedometerRecordHourlyList&quot;</span>: [&#123;<br>            <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;08be23751dc24a4bbca0638ad8880973&quot;</span>,<br>            <span class="hljs-attr">&quot;userId&quot;</span>: <span class="hljs-number">26993431</span>,<br>            <span class="hljs-attr">&quot;deviceId&quot;</span>: <span class="hljs-string">&quot;M_NULL&quot;</span>,<br>            <span class="hljs-attr">&quot;measurementTime&quot;</span>: <span class="hljs-string">&quot;2020-08-22 00:00:00&quot;</span>,<br>            <span class="hljs-attr">&quot;step&quot;</span>: <span class="hljs-string">&quot;9950,9950,0,0,0,0,0,0,0,0,0,0,4550,5650,0,0,9990,0,0,0,0,0,0,0&quot;</span>,<br>            <span class="hljs-attr">&quot;calories&quot;</span>: <span class="hljs-string">&quot;2487.00,2487.00,0,0,0,0,0,0,0,0,0,0,1137.00,1412.00,0,0,2497.00,0,0,0,0,0,0,0&quot;</span>,<br>            <span class="hljs-attr">&quot;distance&quot;</span>: <span class="hljs-string">&quot;3316.00,3316.00,0,0,0,0,0,0,0,0,0,0,1516.00,1883.00,0,0,3330.00,0,0,0,0,0,0,0&quot;</span>,<br>            <span class="hljs-attr">&quot;dataSource&quot;</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">&quot;created&quot;</span>: <span class="hljs-string">&quot;2020-08-22 00:17:42&quot;</span>,<br>            <span class="hljs-attr">&quot;active&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">&quot;updated&quot;</span>: <span class="hljs-number">1598084752590</span><br>        &#125;]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="提交自动刷步"><a href="#提交自动刷步" class="headerlink" title="提交自动刷步"></a>提交自动刷步</h2><p>get请求</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs http">http://你的域名(或者公网ip:8080)/Service/updateStep?phone=18888888888&amp;password=CZ123456&amp;steps=9990&amp;flag=1<br></code></pre></td></tr></table></figure><p>响应</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">508</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;已加入数据库进行定时任务&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><p>响应码</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">200</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;成功&quot;</span>,<br>    <span class="hljs-attr">&quot;data&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;pedometerRecordHourlyList&quot;</span>: [&#123;<br>            <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;08be23751dc24a4bbca0638ad8880973&quot;</span>,<br>            <span class="hljs-attr">&quot;userId&quot;</span>: <span class="hljs-number">26993431</span>,<br>            <span class="hljs-attr">&quot;deviceId&quot;</span>: <span class="hljs-string">&quot;M_NULL&quot;</span>,<br>            <span class="hljs-attr">&quot;measurementTime&quot;</span>: <span class="hljs-string">&quot;2020-08-22 00:00:00&quot;</span>,<br>            <span class="hljs-attr">&quot;step&quot;</span>: <span class="hljs-string">&quot;9950,9950,0,0,0,0,0,0,0,0,0,0,4550,5650,0,0,9990,0,0,0,0,0,0,0&quot;</span>,<br>            <span class="hljs-attr">&quot;calories&quot;</span>: <span class="hljs-string">&quot;2487.00,2487.00,0,0,0,0,0,0,0,0,0,0,1137.00,1412.00,0,0,2497.00,0,0,0,0,0,0,0&quot;</span>,<br>            <span class="hljs-attr">&quot;distance&quot;</span>: <span class="hljs-string">&quot;3316.00,3316.00,0,0,0,0,0,0,0,0,0,0,1516.00,1883.00,0,0,3330.00,0,0,0,0,0,0,0&quot;</span>,<br>            <span class="hljs-attr">&quot;dataSource&quot;</span>: <span class="hljs-number">2</span>,<br>            <span class="hljs-attr">&quot;created&quot;</span>: <span class="hljs-string">&quot;2020-08-22 00:17:42&quot;</span>,<br>            <span class="hljs-attr">&quot;active&quot;</span>: <span class="hljs-number">0</span>,<br>            <span class="hljs-attr">&quot;updated&quot;</span>: <span class="hljs-number">1598084752590</span><br>        &#125;]<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">508</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;已加入数据库进行定时任务&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">407</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;密码错误&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;code&quot;</span>: <span class="hljs-number">510</span>,<br>    <span class="hljs-attr">&quot;msg&quot;</span>: <span class="hljs-string">&quot;手机号长度错误&quot;</span><br>&#125;<br></code></pre></td></tr></table></figure><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>下载地址</p><p><a href="https://chengzzz.lanzous.com/b0cqh4p2h">https://chengzzz.lanzous.com/b0cqh4p2h</a><br>密码:d7ty</p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Idea连接数据库问题汇总</title>
      <link href="/2020/08/21/Idea%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/"/>
      <url>/2020/08/21/Idea%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93%E9%97%AE%E9%A2%98%E6%B1%87%E6%80%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="时区问题"><a href="#时区问题" class="headerlink" title="时区问题"></a>时区问题</h1><h2 id="Server-returns-invalid-timezone-Go-to-‘Advanced’-tab-and-set-‘serverTimezone’-property-manually"><a href="#Server-returns-invalid-timezone-Go-to-‘Advanced’-tab-and-set-‘serverTimezone’-property-manually" class="headerlink" title="Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually."></a>Server returns invalid timezone. Go to ‘Advanced’ tab and set ‘serverTimezone’ property manually.</h2><p>前进的道路充满荆棘。</p><h1 id="错误界面"><a href="#错误界面" class="headerlink" title="错误界面"></a>错误界面</h1><p>IDEA连接mysql，地址，用户名，密码，数据库名，全都配置好了，点测试连接，咔！不成功！</p><p>界面是这样的，</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191009101648442.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXFpa2Vy,size_16,color_FFFFFF,t_70" alt="img"></p><p>翻译过来就是：服务器返回无效时区。进入“高级”选项卡，手动设置“serverTimezone”属性。</p><p>看起来是时区出了问题。时区怎么会出问题？坑真多。网上搜了各种解决办法，琳琅满目，复杂的简单的，总算是解决了！</p><h1 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h1><p>我的问题出在两块，第一，设置mysql的时区。第二，mysql驱动的版本。详细步骤如下：</p><h2 id="第一，设置mysql时区。"><a href="#第一，设置mysql时区。" class="headerlink" title="第一，设置mysql时区。"></a>第一，设置mysql时区。</h2><p>1，我们先来检查下mysql时区。</p><p>( 这里有个小插曲<del>~</del>你的mysql，配置好环境变量了吗 ）</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191009105144295.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXFpa2Vy,size_16,color_FFFFFF,t_70" alt="img"></p><p>配置完环境变量，就可以在命令窗口直接执行下面的命令啦！</p><p>进入命令窗口（Win + R），连接数据库 mysql -hlocalhost -uroot -p，回车，输入密码，回车，如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191009102949109.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXFpa2Vy,size_16,color_FFFFFF,t_70" alt="img"></p><p>2，继续输入 show variables like’%time_zone’;  （注意不要漏掉后面的分号），回车，如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191009103216457.png" alt="img"></p><p>显示 SYSTEM 就是没有设置时区啦。</p><p>3，现在我们来设置时区。</p><p>输入set global time_zone = ‘+8:00’; 注意不要漏掉后面的分号），回车，如图：</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191009103329355.png" alt="img"></p><p>这便是设置成功啦！</p><p>这时你重新连接下数据库，也许能连接成功！如果没有，就继续往下走！</p><h2 id="第二，同步mysql驱动。"><a href="#第二，同步mysql驱动。" class="headerlink" title="第二，同步mysql驱动。"></a>第二，同步mysql驱动。</h2><p>我本机安装的mysql版本是5.7的，那么IDEA要连接mysql也应该匹配下驱动版本。把Driver改成MySQL for 5.1就可以了</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191009103958463.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXFpa2Vy,size_16,color_FFFFFF,t_70" alt="img"></p><p>在点击Test Connection测试下，成功啦！</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191009104510966.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXFpa2Vy,size_16,color_FFFFFF,t_70" alt="img"></p><p>【补充】</p><p>如果，你选的是MySQL，<img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191009105524536.png" alt="img"></p><p>数据库又是其他版本的，也没关系。</p><p>在驱动列表里找到 MySQL ，右边Driver files 里，选择一下你需要的版本，保存就可以了。</p><p><img src= "/img/loading.gif" data-lazy-src="https://img-blog.csdnimg.cn/20191009104656408.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2xpdXFpa2Vy,size_16,color_FFFFFF,t_70" alt="img"></p>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Question </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MyBatis-plus+druid</title>
      <link href="/2020/08/21/MyBatis-plus/"/>
      <url>/2020/08/21/MyBatis-plus/</url>
      
        <content type="html"><![CDATA[<h1 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h1><p>application.yaml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><br><span class="hljs-comment">#服务器端口</span><br><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8080</span><br>  <span class="hljs-attr">tomcat:</span><br>    <span class="hljs-attr">connection-timeout:</span> <span class="hljs-number">10000</span><br><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/mysteps?useSSL=false&amp;useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-attr">min-idle:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">max-active:</span> <span class="hljs-number">50</span><br>      <span class="hljs-attr">max-idle:</span> <span class="hljs-number">10</span><br>      <span class="hljs-attr">initial-size:</span> <span class="hljs-number">1</span><br>      <span class="hljs-attr">max-wait:</span> <span class="hljs-number">5000</span><br><br></code></pre></td></tr></table></figure><h1 id="依赖"><a href="#依赖" class="headerlink" title="依赖"></a>依赖</h1><p>pom</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml">        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>   <br><br><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.alibaba/druid --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.23<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><br></code></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> mysql </category>
          
      </categories>
      
      
        <tags>
            
            <tag> plugin </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Navicat Premium 15破解</title>
      <link href="/2020/08/21/Navicat%20Premium%2015/"/>
      <url>/2020/08/21/Navicat%20Premium%2015/</url>
      
        <content type="html"><![CDATA[<h1 id="Navicat-15-for-MySQL、Navicat-Premium-15和Navicat-12-for-MySQL破解版激活详细教程（注册机无需断网-亲测有效）"><a href="#Navicat-15-for-MySQL、Navicat-Premium-15和Navicat-12-for-MySQL破解版激活详细教程（注册机无需断网-亲测有效）" class="headerlink" title="Navicat 15 for MySQL、Navicat Premium 15和Navicat 12 for MySQL破解版激活详细教程（注册机无需断网 亲测有效）"></a><a href="https://www.cnblogs.com/FRIM/p/12955643.html">Navicat 15 for MySQL、Navicat Premium 15和Navicat 12 for MySQL破解版激活详细教程（注册机无需断网 亲测有效）</a></h1><p>目录</p><ul><li>1.下载地址；</li><li>2.Navicat 15 for MySQL安装；</li><li>3.Navicat 15 for MySQL破解激活；</li></ul><h1 id="一、下载地址"><a href="#一、下载地址" class="headerlink" title="一、下载地址"></a>一、下载地址</h1><p>　　<strong>Navicat官网 ：</strong><a href="http://www.navicat.com.cn/products">传送门</a> （由于官网软件更新无法保证一定能破解，可以去下载下面的安装包）</p><p>​      </p><p>​        蓝奏云下载</p><p>​        <a href="https://chengzzz.lanzous.com/iV2MTfxbvpa">https://chengzzz.lanzous.com/iV2MTfxbvpa</a></p><p>　　Navicat 15 for MySQL（附带Navicat 12 for MySQL安装包和注册机，三款软件破解方法一致，Navicat 15 for MySQL和</p><p>　　Navicat Premium 15都是5.5的注册机，Navicat 12 for MySQL是4.8的注册机且只能三选一，更换时需要删除注册表）:</p><p>　　链接：<a href="https://pan.baidu.com/s/1MKWxvt44iA0X5v9oqJ0qiQ">https://pan.baidu.com/s/1MKWxvt44iA0X5v9oqJ0qiQ</a><br>　　提取码：izhy</p><p>　  Navicat Premium 15（安装包和注册机） :</p><p>　　链接：<a href="https://pan.baidu.com/s/1Q6osjOEYPmFkAmR5WOVB3A">https://pan.baidu.com/s/1Q6osjOEYPmFkAmR5WOVB3A</a><br>　　提取码：wryh</p><p>　　MySQL5.7.16.0（有需要的可以这边下载MySQL数据库5.7版本的，这边就不附带安装教程了）:</p><p>　　链接：<a href="https://pan.baidu.com/s/1xADigqklyNSjuYsvrGetUw">https://pan.baidu.com/s/1xADigqklyNSjuYsvrGetUw</a><br>　　提取码：cmov</p><h1 id="二、Navicat-15-for-MySQL安装"><a href="#二、Navicat-15-for-MySQL安装" class="headerlink" title="二、Navicat 15 for MySQL安装"></a>二、Navicat 15 for MySQL安装</h1><p>1.如若是从Navicat 12 for MySQL更新到Navicat 15 for MySQL，先删除Navicat 12 for MySQL然后清除一下注册表 HKEY_CURRENT_USER\Software\PremiumSoft\Navicat（win+r打开运行输入regedit打开注册表）；</p><p>1.1.下载安装Navicat 15 for MySQL，双击打开安装程序（注意下载时关闭电脑管家和其他杀毒软件，或将<strong>Navicat_Keygen_Patch_V5.5_By_DFoX.exe</strong>加入信任区）；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171134.png"></p><p>2.下一步继续安装；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171158.png"></p><p>3.同意条款；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171213.png"></p><p>4.选择安装目录，创建快捷方式并安装；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171224.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171237.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171246.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171255.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171305.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171315.png"></p><p>这样我们Navicat 15 for MySQL就安装成功了。</p><h1 id="三、Navicat-15-for-MySQL破解激活"><a href="#三、Navicat-15-for-MySQL破解激活" class="headerlink" title="三、Navicat 15 for MySQL破解激活"></a>三、Navicat 15 for MySQL破解激活</h1><p>1.双击打开注册机；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171326.png"></p><p>\2. 如下图所示，选择“Navicat v15”，（可选项 ：Products选择“MySQL”），Languages选择“Simplified Chinese”，然后点击“Patch”，进行注册；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171339.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171351.png"></p><p>3.找到安装文件夹并选择navicat.exe打开；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171401.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171412.png"></p><p>4.打开双击打开Navicat 15 for MySQL，选择注册（如果第一次安装的话，打开软件就会提示注册，如果之前遗留有注册信息，可以通过点击帮助 》注册）；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171423.png"></p><p>5.返回注册机点击Generate生成许可证秘钥，如下图所示：</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171437.png"></p><p>6.将生成许可证秘钥复制到Navicat 15 for MySQL上并显示✔才为正确，显示✘可继续点击Generate更换许可证秘钥；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171448.png"></p><p>7选择手动激活；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171502.png"></p><p>7.将请求码复制到注册机上的Request Code输入框中；然后点击“Generate”，生成激活码（此处自动将生成的激活复制到Navicat 15 for MySQL上）；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171518.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171536.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171547.png"></p><p>8.点击激活；</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171603.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171613.png"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822171623.png"></p><p>转载至<a href="https://www.cnblogs.com/FRIM/p/12955643.html">https://www.cnblogs.com/FRIM/p/12955643.html</a></p>]]></content>
      
      
      <categories>
          
          <category> DataBase </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tools </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android</title>
      <link href="/2020/08/19/Android/"/>
      <url>/2020/08/19/Android/</url>
      
        <content type="html"><![CDATA[<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="返回栈"><a href="#返回栈" class="headerlink" title="返回栈"></a>返回栈</h2><p> Android其实是通过任务(task)来管理Activity的，每一个task都是一组存放在栈中的Activity集合，这个栈也称为返回栈(back stack),栈是一种后进先出的数据结构。在默认情况下，我们启动了一个新的Activity，他就会在返回栈中入栈，并处于栈顶的位置。每当我们启动新的Activity时，都会在返回栈中入栈，且位于栈顶。而当我们back或者finish销毁Activity时，处于当前返回栈栈顶的Activity将会出栈，前一个入栈的Activity将会处于栈顶的位置。系统总是会显示处于栈顶的Activity给用户。</p><hr><h2 id="Activity的状态"><a href="#Activity的状态" class="headerlink" title="Activity的状态"></a>Activity的状态</h2><ol><li><p>运行状态</p><p>当Activity处于栈顶，且为可见状态时，即为运行状态。系统不愿意回收可见状态的Activity，因为这会给用户带来极差的体验。</p></li><li><p>暂停状态</p><p>当Activity不处在栈顶，且不完全为可见状态时，即为暂停状态。<code>例如对话框形式的Activity即只占用了部分区域的Activity</code> 系统也不愿意回收这种Activity，只有在内存极低的情况下系统才会去考虑回收这种Activity</p></li><li><p>停止状态</p><p>当Activity不处于栈顶，且完全不可见时，即为停止状态，系统仍然会为这种Activity保存相应的状态和成员变量，但这并不是完全可靠的，当其他地方需要内存时，处于停止状态的Activity有可能被系统回收。</p></li><li><p>销毁状态</p><p>一个Activity从栈中移除后就变成了销毁状态。系统倾向于回收这种状态的Activity，以保存系统内存的充足。</p></li></ol><p>未完待续…</p><hr><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml">android:launchMopde=&quot;xxxx&quot;<br></code></pre></td></tr></table></figure><ol><li>standard<ol><li>创建一个活动并入栈</li></ol></li><li>singleTop<ol><li>直接使用栈顶的活动，若需求活动不处于栈顶，则依旧重新实例化该活动并入栈</li></ol></li><li>singleTask<ol><li>检测返回栈中已存在的活动，若需求活动已存在则直接使用置于栈顶并将其上的活动出栈。若不存在则重新实例化并入栈</li></ol></li><li>singleInstance<ol><li>创建一个单独的共享返回栈来存放管理该模式的活动，以便于提供给其他程序对于该活动实列的访问。</li></ol></li></ol><hr><h2 id="关于Activity的灵活使用案例"><a href="#关于Activity的灵活使用案例" class="headerlink" title="关于Activity的灵活使用案例"></a>关于Activity的灵活使用案例</h2><hr><h1 id="UI"><a href="#UI" class="headerlink" title="UI"></a>UI</h1><h2 id="UI开发工具"><a href="#UI开发工具" class="headerlink" title="UI开发工具"></a>UI开发工具</h2><hr><h2 id="基本布局"><a href="#基本布局" class="headerlink" title="基本布局"></a>基本布局</h2><hr><h2 id="基本控件"><a href="#基本控件" class="headerlink" title="基本控件"></a>基本控件</h2><hr><h2 id="自定义控件"><a href="#自定义控件" class="headerlink" title="自定义控件"></a>自定义控件</h2><hr><h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><hr><h1 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h1>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring</title>
      <link href="/2020/08/18/Spring%E7%AC%94%E8%AE%B0/"/>
      <url>/2020/08/18/Spring%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-QBFyaJxn" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h1 id="爬坑Spring"><a href="#爬坑Spring" class="headerlink" title="爬坑Spring"></a>爬坑Spring</h1><p>[TOC]</p><h2 id="Spring简介"><a href="#Spring简介" class="headerlink" title="Spring简介"></a>Spring简介</h2><h3 id="1-1-官网"><a href="#1-1-官网" class="headerlink" title="1.1 官网"></a>1.1 官网</h3><p><a href="https://spring.io/">spring官网</a></p><p><a href="https://docs.spring.io/spring/docs/current/spring-framework-reference/core.html">spring文档</a></p><p><a href="https://www.docs4dev.com/docs/zh/spring-framework/5.1.3.RELEASE/reference">spring中文文档</a></p><h3 id="1-2-理念"><a href="#1-2-理念" class="headerlink" title="1.2 理念"></a>1.2 理念</h3><p>使现有的技术更加容易使用，本身是一个大杂烩，整合了现有的技术框架</p><h3 id="1-3-优点"><a href="#1-3-优点" class="headerlink" title="1.3 优点"></a>1.3 优点</h3><ul><li><p>Spring是一个开源的免费的框架(容器)</p></li><li><p>Spring是一个轻量级的、非侵入式的框架</p></li><li><p>控制权反转 IOC，面向切面编程 AOP</p></li><li><p>支持事务的处理，对框架整合的支持</p></li></ul><h3 id="1-4-组成"><a href="#1-4-组成" class="headerlink" title="1.4 组成"></a>1.4 组成</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151520.png"></p><h3 id="1-5-拓展"><a href="#1-5-拓展" class="headerlink" title="1.5 拓展"></a>1.5 拓展</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151531.png"></p><ul><li><p>Spring boot</p><ul><li>一个快速开发的脚手架。</li><li>基于Spring Boot可以快速开发单个微服务。</li><li>约定大于配置。</li></ul></li><li><p>Spring Cloud</p><ul><li>基于Spring Boot实现的。</li></ul></li></ul><p>== 现在大部分公司都在使用Spring Boot进行快速开发，学习Spring Boot的前提，需要完全掌握Spring 及 SpringMVC == </p><p><strong>Spring弊端：发展太久后违背了最初理念，配置十分繁琐，直至Spring Boot的出现</strong></p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><h3 id="2-1-IOC的推导"><a href="#2-1-IOC的推导" class="headerlink" title="2.1 IOC的推导"></a>2.1 IOC的推导</h3><h4 id="2-1-1-初识控制权反转"><a href="#2-1-1-初识控制权反转" class="headerlink" title="2.1.1 初识控制权反转"></a>2.1.1 初识控制权反转</h4><ol><li>UserDao 接口</li><li>UserDaoImpl 接口实现类</li><li>UserService 业务接口</li><li>UserServiceImpl 业务实现类</li></ol><h5 id="IOC原型之静态生成对象–控制权掌握在程序员手中"><a href="#IOC原型之静态生成对象–控制权掌握在程序员手中" class="headerlink" title="IOC原型之静态生成对象–控制权掌握在程序员手中"></a>IOC原型之静态生成对象–控制权掌握在程序员手中</h5><pre class="language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService&#123;    private UserDao userDao &#x3D;new UserDaoMysqlImpl();    public void getUser() &#123;        userDao.getUser();    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;用户调用业务层，dao无需接触        UserServiceImpl userService &#x3D; new UserServiceImpl();        userService.getUser();    &#125;&#125;</code></pre><p>通过new的方式，在service层静态的，固定的给出了业务实现，用户无法进行控制。</p><hr><h5 id="IOC原型之动态生成对象–控制权掌握在用户手中"><a href="#IOC原型之动态生成对象–控制权掌握在用户手中" class="headerlink" title="IOC原型之动态生成对象–控制权掌握在用户手中"></a>IOC原型之动态生成对象–控制权掌握在用户手中</h5><pre class="language-java" data-language="java"><code class="language-java">public class UserServiceImpl implements UserService&#123;    private UserDao userDao;    &#x2F;&#x2F;使用set进行注入    public void setUserDao(UserDao userDao) &#123;        this.userDao &#x3D; userDao;    &#125;    public void getUser() &#123;        userDao.getUser();    &#125;&#125;</code></pre><p>通过set方法注入，使得service层动态加载业务，具体业务的种类的选择权转移到了用户手中。</p><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;用户调用业务层，dao无需接触        UserServiceImpl userService &#x3D; new UserServiceImpl();        userService.setUserDao(new UserDaoMysqlImpl());        userService.getUser();    &#125;&#125;</code></pre><ul><li><p>之前，程序是主动创建对象，控制权在程序员手中。</p></li><li><p>使用set注入之后，程序不再具有主动性，控制权转移到了用户手中。</p><h5 id="IOC本质"><a href="#IOC本质" class="headerlink" title="IOC本质"></a>IOC本质</h5></li></ul><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151544.png"></p><ul><li>过去，如图1，我们希望在四个模块中间有一个中间件进行联系，那么我们只需要调用中间件即可访问其他模块</li><li>于是乎IOC容器诞生了，由IOC容器连接模块，模块间不再具有强耦合性，用户决定调用的方向。</li></ul><p><code>总结：控制权反转(IOC)，是一种使得程序从主动改变转换为被动接收，将控制权由开发人员手中转移到用户手中的设计思想而非具体实现方法，DI(依赖注入)是实现IOC的一种方法</code></p><p><code>控制权反转是一种通过描述(XML或注解)并通过第三方去生产或获取特定对象的方式。在Spring中实现控制权反转的是IOC容器，其实现的方法为依赖注入(Dependency Injection,DI)</code></p><hr><h4 id="2-1-2-第一个Spring程序"><a href="#2-1-2-第一个Spring程序" class="headerlink" title="2.1.2  第一个Spring程序"></a>2.1.2  第一个Spring程序</h4><h5 id="配置文件的编写"><a href="#配置文件的编写" class="headerlink" title="配置文件的编写"></a>配置文件的编写</h5><h6 id="使用XML"><a href="#使用XML" class="headerlink" title="使用XML"></a>使用XML</h6><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;    &lt;bean id&#x3D;&quot;Mysql&quot; class&#x3D;&quot;com.chengzzz.dao.UserDaoMysqlImpl&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;oracle&quot; class&#x3D;&quot;com.chengzzz.dao.UserDaoOracleImpl&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.chengzzz.dao.UserDaoImpl&quot;&#x2F;&gt;    &lt;bean id&#x3D;&quot;userservices&quot; class&#x3D;&quot;com.chengzzz.service.UserServiceImpl&quot;&gt;        &lt;!--        ref:引用容器中创建好的对象         value:具体的值        --&gt;        &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;user&quot;&gt;&lt;&#x2F;property&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><p><code>以上Bean类通过在XML中声明后，即可通过ApplicationContext ApplicationContext = new ClassPathXmlApplicationContext(&quot;beans.xml&quot;)读取到配置文件，从而使得IOC容器实现控制权反转</code></p><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;        ApplicationContext ApplicationContext &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        UserService userservices &#x3D; ApplicationContext.getBean(&quot;userservices&quot;,UserServiceImpl.class);        userservices.getUser();    &#125;&#125;</code></pre><p><code>以上即为Spring通过xml 实现控制权反转后产生的实体类对象，通过getBean方法获取并得以使用</code></p><h6 id="使用注解"><a href="#使用注解" class="headerlink" title="使用注解"></a>使用注解</h6><h6 id="使用纯java代码"><a href="#使用纯java代码" class="headerlink" title="使用纯java代码"></a>使用纯java代码</h6><h5 id="IOC对象的创建"><a href="#IOC对象的创建" class="headerlink" title="IOC对象的创建"></a>IOC对象的创建</h5><h6 id="IOC创建对象的方式"><a href="#IOC创建对象的方式" class="headerlink" title="IOC创建对象的方式"></a>IOC创建对象的方式</h6><ol><li><p>无参构造器创建对象，默认方法</p><pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot;&gt;&lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</code></pre></li></ol><ol start="2"><li><p>有参构造创建对象</p><p>下标注入</p><pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot;&gt; &lt;constructor-arg index&#x3D;&quot;0&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;constructor-arg&gt;&lt;&#x2F;bean&gt;</code></pre></li></ol><p>   类型注入</p>   <pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot;&gt;    &lt;constructor-arg type&#x3D;&quot;java.lang.String&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;constructor-arg&gt;&lt;&#x2F;bean&gt;</code></pre><p>   参数名注入</p>   <pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot;&gt;    &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;constructor-arg&gt;&lt;&#x2F;bean&gt;</code></pre><hr><h2 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h2><h3 id="3-1-alisas-别名"><a href="#3-1-alisas-别名" class="headerlink" title="3.1 alisas(别名)"></a>3.1 alisas(别名)</h3><pre class="language-java" data-language="java"><code class="language-java">&lt;alias name&#x3D;&quot;hello&quot; alias&#x3D;&quot;hello2&quot;&gt;&lt;&#x2F;alias&gt;</code></pre><p>没什么卵用</p><pre class="language-java" data-language="java"><code class="language-java">&lt;bean id&#x3D;&quot;hello&quot; class&#x3D;&quot;com.chengzzz.pojo.Hello&quot; name&#x3D;&quot;hello2,hello1&quot;&gt;    &lt;constructor-arg name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;constructor-arg&gt;&lt;&#x2F;bean&gt;</code></pre><p>在bean的注册中可以使用name来写入别名</p><hr><h3 id="3-2-Import"><a href="#3-2-Import" class="headerlink" title="3.2 Import"></a>3.2 Import</h3><p>导入配置文件，团队开发中，含有多个配置文件时可以使用import将所有的配置文件合并为一个。</p><pre class="language-java" data-language="java"><code class="language-java">&lt;import resource&#x3D;&quot;beans1.xml&quot;&gt;&lt;&#x2F;import&gt;&lt;import resource&#x3D;&quot;beans2.xml&quot;&gt;&lt;&#x2F;import&gt;&lt;import resource&#x3D;&quot;beans3.xml&quot;&gt;&lt;&#x2F;import&gt;</code></pre><p><code>注意重名时，后导入的会覆盖前导入的</code></p><hr><h2 id="DI-依赖注入"><a href="#DI-依赖注入" class="headerlink" title="DI(依赖注入)"></a>DI(依赖注入)</h2><h3 id="4-1-构造器注入"><a href="#4-1-构造器注入" class="headerlink" title="4.1 构造器注入"></a>4.1 构造器注入</h3><p>参考上文  <strong>IOC创建对象的方式</strong></p><hr><h3 id="4-2-Set方法注入"><a href="#4-2-Set方法注入" class="headerlink" title="4.2 Set方法注入"></a><strong>4.2 Set方法注入</strong></h3><p><strong>Set方法注入【重点</strong>】</p><ul><li>Set注入是依赖注入的本质，依赖注入的本质是Set注入<ul><li>依赖：bean对象的创建依赖于容器</li><li>注入：bean对象中的所有属性，都由容器来注入</li></ul></li></ul><p>测试环境</p><p>Student类</p><pre class="language-java" data-language="java"><code class="language-java">public class Student &#123;    private String name;    private Address address;    private String[] books;    private List&lt;String&gt; hobbys;    private Map&lt;String,String&gt; card;    private Set&lt;String&gt; games;    private String wife;    private Properties info;    &#x2F;*get set tosting方法省略*&#x2F;&#125;</code></pre><p>Address类</p><pre class="language-java" data-language="java"><code class="language-java">public class Address &#123;    private String address;&#x2F;*get set tosting方法省略*&#x2F;&#125;</code></pre><p>beans.xml</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.chengzzz.pojo.Student&quot;&gt;       &lt;!--普通值注入--&gt;       &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;property&gt;   &lt;&#x2F;bean&gt;   &lt;bean id&#x3D;&quot;address&quot; class&#x3D;&quot;com.chengzzz.pojo.Address&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><p>完整注入xml</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;student&quot; class&#x3D;&quot;com.chengzzz.pojo.Student&quot;&gt;    &lt;!--1.普通值注入 value--&gt;    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;小橙子&quot;&gt;&lt;&#x2F;property&gt;    &lt;!--2.bean注入 ref--&gt;    &lt;property name&#x3D;&quot;address&quot; ref&#x3D;&quot;address&quot;&gt;&lt;&#x2F;property&gt;    &lt;!--3.数组注入 ref--&gt;    &lt;property name&#x3D;&quot;books&quot;&gt;        &lt;array&gt;            &lt;value&gt;红楼梦&lt;&#x2F;value&gt;            &lt;value&gt;西游记&lt;&#x2F;value&gt;            &lt;value&gt;三国演义&lt;&#x2F;value&gt;            &lt;value&gt;水浒传&lt;&#x2F;value&gt;        &lt;&#x2F;array&gt;    &lt;&#x2F;property&gt;    &lt;!--4.list注入--&gt;    &lt;property name&#x3D;&quot;hobbys&quot;&gt;        &lt;list&gt;            &lt;value&gt;打游戏&lt;&#x2F;value&gt;            &lt;value&gt;听歌&lt;&#x2F;value&gt;            &lt;value&gt;睡觉&lt;&#x2F;value&gt;        &lt;&#x2F;list&gt;    &lt;&#x2F;property&gt;    &lt;!--5.map注入--&gt;    &lt;property name&#x3D;&quot;card&quot;&gt;        &lt;map&gt;            &lt;entry key&#x3D;&quot;身份证&quot; value&#x3D;&quot;111&quot;&gt;&lt;&#x2F;entry&gt;            &lt;entry key&#x3D;&quot;银行卡&quot; value&#x3D;&quot;222&quot;&gt;&lt;&#x2F;entry&gt;            &lt;entry key&#x3D;&quot;校园卡&quot; value&#x3D;&quot;333&quot;&gt;&lt;&#x2F;entry&gt;        &lt;&#x2F;map&gt;    &lt;&#x2F;property&gt;    &lt;!--6.set注入--&gt;    &lt;property name&#x3D;&quot;games&quot;&gt;        &lt;set&gt;            &lt;value&gt;lol&lt;&#x2F;value&gt;            &lt;value&gt;wow&lt;&#x2F;value&gt;        &lt;&#x2F;set&gt;    &lt;&#x2F;property&gt;    &lt;!--7.null注入--&gt;    &lt;property name&#x3D;&quot;wife&quot;&gt;        &lt;null&gt;&lt;&#x2F;null&gt;    &lt;!--8.Properties注入--&gt;    &lt;&#x2F;property&gt;    &lt;property name&#x3D;&quot;info&quot;&gt;        &lt;props&gt;            &lt;prop key&#x3D;&quot;drive&quot;&gt;12333&lt;&#x2F;prop&gt;            &lt;prop key&#x3D;&quot;sex&quot;&gt;女&lt;&#x2F;prop&gt;        &lt;&#x2F;props&gt;    &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;address&quot; class&#x3D;&quot;com.chengzzz.pojo.Address&quot;&gt;&lt;&#x2F;bean&gt;</code></pre><h3 id="4-3-拓展方式注入"><a href="#4-3-拓展方式注入" class="headerlink" title="4.3 拓展方式注入"></a>4.3 拓展方式注入</h3><ul><li><p>P命名空间注入(p=property即属性注入)</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;     xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;      xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;     xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;  &lt;!--p命名空间注入--&gt;  &lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;com.chengzzz.pojo.User&quot; p:name&#x3D;&quot;小橙子&quot; p:age&#x3D;&quot;18&quot;&#x2F;&gt;  &lt;&#x2F;beans&gt;</code></pre></li></ul><ul><li><p>C命名空间注入(c=constructor-arg即构造器注入)</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;     xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;        xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;     xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;  &lt;!--c命名空间注入--&gt;  &lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;com.chengzzz.pojo.User&quot; c:name&#x3D;&quot;小橙子&quot; c:age&#x3D;&quot;19&quot;&#x2F;&gt;  &lt;&#x2F;beans&gt;</code></pre><p><code>注意 p命名空间注入为属性注入即set注入  而set注入必须有无参构造器  c命名空间为有参构造器注入 实体类需重写有参构造方法</code></p><p><code>c命名空间 p命名空间不能直接使用 需要导入依赖</code></p></li></ul><hr><h3 id="4-4-Bean的作用域"><a href="#4-4-Bean的作用域" class="headerlink" title="4.4 Bean的作用域"></a>4.4 Bean的作用域</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151603.png"></p><ol><li><p>单例模式【Spring默认模式】</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;com.chengzzz.pojo.User&quot; c:name&#x3D;&quot;小橙子&quot; c:age&#x3D;&quot;19&quot; scope&#x3D;&quot;singleton&quot;&#x2F;&gt;</code></pre></li></ol><ol start="2"><li><p>原型模式</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;com.chengzzz.pojo.User&quot; c:name&#x3D;&quot;小橙子&quot; c:age&#x3D;&quot;19&quot; scope&#x3D;&quot;prototype&quot;&#x2F;&gt;</code></pre></li><li><p>其余的request、sesstion、application只在web开发中使用到</p></li></ol><hr><h2 id="Bean的自动装配"><a href="#Bean的自动装配" class="headerlink" title="Bean的自动装配"></a>Bean的自动装配</h2><ul><li>自动装配是Spring满足bean依赖的一种方式。</li><li>Spring会在上下文中自动寻找，并自动给bean装配属性</li></ul><p>Spring中装配方式有三种</p><ol><li>在xml中显式地配置</li><li>在java中显式地配置</li><li><strong>隐式的自动装配bean 【重要】</strong></li></ol><h3 id="5-1测试"><a href="#5-1测试" class="headerlink" title="5.1测试"></a>5.1测试</h3><p>测试类</p><pre class="language-java" data-language="java"><code class="language-java">public class Cat &#123;    public void shout()&#123;        System.out.println(&quot;喵喵喵&quot;);    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class Dog &#123;    public void shout()&#123;        System.out.println(&quot;汪汪汪&quot;);    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class People &#123;    private Cat cat;    private Dog dog;    private String name;    public Cat getCat() &#123;        return cat;    &#125;    public void setCat(Cat cat) &#123;        this.cat &#x3D; cat;    &#125;    public Dog getDog() &#123;        return dog;    &#125;    public void setDog(Dog dog) &#123;        this.dog &#x3D; dog;    &#125;    public String getName() &#123;        return name;    &#125;    public void setName(String name) &#123;        this.name &#x3D; name;    &#125;&#125;</code></pre><p>配置文件</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;cat&quot; class&#x3D;&quot;www.chengzzz.pojo.Cat&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;dog&quot; class&#x3D;&quot;www.chengzzz.pojo.Dog&quot;&gt;&lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;people&quot; class&#x3D;&quot;www.chengzzz.pojo.People&quot;&gt;    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;xxx&quot;&gt;    &lt;&#x2F;property&gt;    &lt;property name&#x3D;&quot;cat&quot; ref&#x3D;&quot;cat&quot;&gt;    &lt;&#x2F;property&gt;    &lt;property name&#x3D;&quot;dog&quot; ref&#x3D;&quot;dog&quot;&gt;&lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</code></pre><hr><h3 id="5-2-自动装配的方式"><a href="#5-2-自动装配的方式" class="headerlink" title="5.2 自动装配的方式"></a>5.2 自动装配的方式</h3><ol><li><p>byName(在容器上下文中查找和自己对象set方法后面的值对应的beanid) 名字必须唯一</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;people&quot; class&#x3D;&quot;www.chengzzz.pojo.People&quot; autowire&#x3D;&quot;byName&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;xxx&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre></li></ol><ol start="2"><li><p>byType(在容器上下文中查找和自己对象属性类型相同的bean) </p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;people&quot; class&#x3D;&quot;www.chengzzz.pojo.People&quot; autowire&#x3D;&quot;byType&quot;&gt; &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;xxx&quot;&gt; &lt;&#x2F;property&gt;&lt;&#x2F;bean&gt;</code></pre></li></ol><p>   <code>小节</code></p><ul><li>byname的时候。需要保证所有bean的id唯一，并且这个bean需要和自动注入的属性的set方法值一致。</li><li>bytype的时候。需要保证所有bean的class唯一，并且这个bean需要和自动注入的属性的类型一致</li></ul><hr><h3 id="5-3-使用注解实现自动装配"><a href="#5-3-使用注解实现自动装配" class="headerlink" title="5.3 使用注解实现自动装配"></a>5.3 使用注解实现自动装配</h3><p>JDK从1.5开始支持的注解，Spring从2.5就开始支持注解</p><p><code>使用注解注意点</code></p><ol><li><p>导入约束</p><p>&lt;!–hexoPostRenderEscape:<pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;<br>&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;<a href="http://www.springframework.org&/#x2F;schema&#x2F;beans">www.springframework.org&#x2F;schema&#x2F;beans</a>&quot;</p><pre><code>xmlns:xsi&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.w3.org&amp;#x2F;2001&amp;#x2F;XMLSchema-instance&amp;quot;xmlns:context&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;context&amp;quot;xsi:schemaLocation&amp;#x3D;&amp;quot;http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;beans http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;beans&amp;#x2F;spring-beans.xsd http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;context http:&amp;#x2F;&amp;#x2F;www.springframework.org&amp;#x2F;schema&amp;#x2F;beans&amp;#x2F;spring-context.xsd&amp;quot;&amp;gt;</code></pre></li></ol><p>&lt;&#x2F;beans&gt;</code></pre>:hexoPostRenderEscape–&gt;</p><ol start="2"><li>开启注解支持</li></ol><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;context:annotation-config&#x2F;&gt;</code></pre><p>在属性上直接使用也可以在set方法上使用，实体类可以没有set方法前提是符合byType</p><pre class="language-java" data-language="java"><code class="language-java">@Autowired@Qualifier(value &#x3D; &quot;cat&quot;)  &#x2F;&#x2F;此注解可指定自动装配name为cat的bean</code></pre><p><code>Tips</code></p><pre class="language-xml" data-language="xml"><code class="language-xml">@Nullable &#x2F;&#x2F;字段标记了这个注解 说明这个字段可以为null@Autowired(required&#x3D;false) &#x2F;&#x2F;表示这个对象可以为null@Resource &#x2F;&#x2F;jdk的注解，亦可指定@Resource(name&#x3D;&quot;cat&quot;)  此注解在jdk11中被移除</code></pre><p><code>@Resource和@Autowired的区别</code></p><ul><li>都是用来自动装配的，都可以放在属性字段上</li><li>@AutoWired默认通过byType实现，必须要求其存在，否则空指针</li><li>@Resource默认通过byName方式实现，如果找不到名字则通过byType实现，如果找不到则报错。</li></ul><hr><h2 id="使用注解开发"><a href="#使用注解开发" class="headerlink" title="使用注解开发"></a>使用注解开发</h2><p>在Spring4之后 要使用注解开发，必须导入aop的包</p><p>需要导入context的约束，开启注解支持</p><p><code>注解</code></p><pre class="language-xml" data-language="xml"><code class="language-xml">@Component &#x2F;&#x2F;声明此类为自动装配的组件，配合自动扫描包实现自动装配@Value(&quot;小橙子&quot;) &#x2F;&#x2F;赋值，相当于属性注入中的value@Repository &#x2F;&#x2F;Dao层的标注Component的衍生注解@Service  &#x2F;&#x2F;Service层的标注Component的衍生注解@Controller  &#x2F;&#x2F;Controller层的标注Component的衍生注解@AutoWired &#x2F;&#x2F;自动装配的注解@Scope  &#x2F;&#x2F;模式注解 @Configuration &#x2F;&#x2F;使用java代码实现xml配置@ComponentScan(&quot;com.chengzzz.pojo&quot;)&#x2F;&#x2F;扫描指定的包@Import(bean2.class) &#x2F;&#x2F;导入另外的配置文件@Aspect &#x2F;&#x2F;切面</code></pre><p><code>xml与注解</code></p><ol><li>xml更加万能，维护简单方便</li><li>注解不是自己的类使用不了，维护相对复杂</li></ol><p><code>xml与注解的最佳实现</code></p><ol><li>xml用来管理bean</li><li>注解只负责属性的注入</li><li>我们在使用的过程中只需要注意一个问题：必须让注解生效，就必须开启注解支持。</li></ol><h3 id="6-1-开启注解支持"><a href="#6-1-开启注解支持" class="headerlink" title="6.1 开启注解支持"></a>6.1 开启注解支持</h3><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;!--开启注解支持--&gt; &lt;context:annotation-config&#x2F;&gt; &lt;!--指定需要扫描的包，这个包下的注解会生效--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.chengzzz.pojo&quot;&#x2F;&gt;</code></pre><hr><h3 id="6-2-使用JavaConfig实现配置"><a href="#6-2-使用JavaConfig实现配置" class="headerlink" title="6.2 使用JavaConfig实现配置"></a>6.2 使用JavaConfig实现配置</h3><p>我们现在完全使用java来实现配置</p><p>JavaConfigs Spring的一个子项目，在Spring4之后，他成为了一个核心功能</p><pre class="language-java" data-language="java"><code class="language-java">@Configuration@ComponentScan(&quot;com.chengzzz.pojo&quot;)@Import(bean2.class)public class MyConfig &#123;    @Bean    public User getUser()&#123;        return new User();    &#125;&#125;</code></pre><p>这种纯Java的配置方式，在SpringBoot中随处可见</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151618.png"></p><p>Spring Aop支持五种类型</p><p><img src= "/img/loading.gif" data-lazy-src="C:\Users\Yet\AppData\Roaming\Typora\typora-user-images\image-20200804132547513.png" alt="image-20200804132547513"></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151628.png"></p><p>需要导入依赖包</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;    &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver --&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;&#x2F;groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;&#x2F;artifactId&gt;        &lt;version&gt;1.9.5&lt;&#x2F;version&gt;    &lt;&#x2F;dependency&gt;&lt;&#x2F;dependencies&gt;</code></pre><hr><h3 id="7-1-代理模式"><a href="#7-1-代理模式" class="headerlink" title="7.1 代理模式"></a>7.1 代理模式</h3><p>为什么要学习代理模式？</p><p>因为这就是SpringAop的底层【SpringAop和SpringMVC】</p><p>代理模式的分类：</p><ul><li>静态代理</li><li>动态代理</li></ul><hr><h4 id="7-1-静态代理"><a href="#7-1-静态代理" class="headerlink" title="7.1 静态代理"></a>7.1 静态代理</h4><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151638.png"></p><p>角色分析：</p><ul><li>抽象角色：一般使用接口或者抽象类来解决</li><li>真实角色：被代理的角色</li><li>代理角色：代理真实角色 ，代理真实角色后，我们一般会做一些附加操作</li><li>客户：访问代理对象的角色</li></ul><p>静态代理模式的好处：</p><ul><li>可以使得真实角色的操作更加纯粹，不用去关注一些公共的业务</li><li>公共业务交给代理角色，实现了业务的分工</li><li>公共业务发生扩展的时候方便集中管理</li></ul><p>静态代理模式的缺点：</p><ul><li>一个真实角色就会产生一个代理角色：代码量翻倍，开发效率变低</li></ul><p><code>AOP初识</code></p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818151653.png"></p><hr><h4 id="7-2-动态代理"><a href="#7-2-动态代理" class="headerlink" title="7.2 动态代理"></a>7.2 动态代理</h4><ul><li>动态代理和静态代理角色一样</li><li>动态代理的类是动态生成的，不是直接写好的</li><li>动态代理分为两大类：基于接口的动态代理，基于类的动态代理<ul><li>基于接口—-JDK动态代理</li><li>基于类—-cglib</li><li>基于java字节码—-javassist</li></ul></li></ul><p>需要了解两个类 Proxy:代理，InvocationHandler:调用处理程序</p><pre class="language-java" data-language="java"><code class="language-java">&#x2F;&#x2F;重写这个类，实现自动代理public class ProxyInvocationHandler implements InvocationHandler &#123;    &#x2F;&#x2F;被代理的接口    private Object target;    public void setTarget(Object target) &#123;        this.target &#x3D; target;    &#125;    &#x2F;&#x2F;得到代理类    public Object getProxy()&#123;        return Proxy.newProxyInstance(this.getClass().getClassLoader(),target.getClass().getInterfaces(),this);    &#125;    &#x2F;&#x2F;处理代理实例，并返回结果    @Override    public Object invoke(Object o, Method method, Object[] objects) throws Throwable &#123;        &#x2F;&#x2F;动态代理就是利用反射机制实现        Object result &#x3D; method.invoke(target, objects);        return result;    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class User &#123;    public static void main(String[] args) &#123;        &#x2F;&#x2F;真实角色        App app &#x3D; new App();        &#x2F;&#x2F;代理角色        ProxyInvocationHandler proxyInvocationHandler &#x3D; new ProxyInvocationHandler();        proxyInvocationHandler.setTarget(app);        Download proxy &#x3D; (Download) proxyInvocationHandler.getProxy();        proxy.download();    &#125;&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public interface Download &#123;    void download();&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class App implements Download&#123;    @Override    public void download() &#123;        System.out.println(&quot;下载&quot;);    &#125;&#125;</code></pre><p>动态代理的优点：</p><ul><li>可以使得真实角色的操作更加纯粹，不用去关注一些公共的业务</li><li>公共业务交给代理角色，实现了业务的分工</li><li>公共业务发生扩展的时候方便集中管理</li><li>一个动态代理类可以代理多个类，只要是实现了同一个接口即可</li></ul><hr><h3 id="7-2-AOP实现方式一"><a href="#7-2-AOP实现方式一" class="headerlink" title="7.2 AOP实现方式一"></a>7.2 AOP实现方式一</h3><p><code>使用Spring的api</code></p><pre class="language-java" data-language="java"><code class="language-java">public class beforlog implements AfterReturningAdvice &#123;    @Override    public void afterReturning(Object o, Method method, Object[] objects, Object o1) throws Throwable &#123;        System.out.println(o1.getClass().getName()+&quot;----&quot;+method.getName());    &#125;&#125;</code></pre><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;services&quot; class&#x3D;&quot;com.chengzzz.services.ServicesImpl&quot;&#x2F;&gt;&lt;bean id&#x3D;&quot;log&quot; class&#x3D;&quot;com.chengzzz.log.beforlog&quot;&#x2F;&gt;&lt;aop:config&gt;    &lt;!--注册切点--&gt;    &lt;aop:pointcut id&#x3D;&quot;point&quot; expression&#x3D;&quot;execution(* com.chengzzz.services.ServicesImpl.*(..))&quot;&#x2F;&gt;    &lt;!--注册切入方式--&gt;    &lt;aop:advisor advice-ref&#x3D;&quot;log&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;&lt;&#x2F;aop:config&gt;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;      ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Services services &#x3D; context.getBean(&quot;services&quot;, Services.class);        services.query();    &#125;&#125;</code></pre><p><code>由于动态代理代理的是接口，所以getBean时，需要转换为接口</code></p><hr><h3 id="7-3-AOP实现方式二"><a href="#7-3-AOP实现方式二" class="headerlink" title="7.3 AOP实现方式二"></a>7.3 AOP实现方式二</h3><p><code>使用自定义类实现aop</code></p><pre class="language-java" data-language="java"><code class="language-java">public class DiyPointCut &#123;    public void before()&#123;        System.out.println(&quot;before&quot;);    &#125;    public void after()&#123;        System.out.println(&quot;after&quot;);    &#125;&#125;</code></pre><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;!--切面对象--&gt;&lt;bean id&#x3D;&quot;diypoint&quot; class&#x3D;&quot;com.chengzzz.diy.DiyPointCut&quot;&#x2F;&gt;&lt;aop:config&gt;    &lt;!--自定义切面--&gt;    &lt;aop:aspect ref&#x3D;&quot;diypoint&quot; &gt;        &lt;!--注册切点--&gt;        &lt;aop:pointcut id&#x3D;&quot;point&quot; expression&#x3D;&quot;execution(* com.chengzzz.services.ServicesImpl.*(..))&quot;&#x2F;&gt;        &lt;!--注册通知，通知spring 什么时候（method&#x3D;&quot;before&quot; 即动态代理前后） 对切点执行什么方法（DiyPointCut中的方法）--&gt;        &lt;aop:before method&#x3D;&quot;before&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;        &lt;aop:after method&#x3D;&quot;after&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;    &lt;&#x2F;aop:aspect&gt;&lt;&#x2F;aop:config&gt;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;      ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Services services &#x3D; context.getBean(&quot;services&quot;, Services.class);        services.query();    &#125;&#125;</code></pre><p><code>由于动态代理代理的是接口，所以getBean时，需要转换为接口</code></p><hr><h3 id="7-4-AOP实现方式三"><a href="#7-4-AOP实现方式三" class="headerlink" title="7.4 AOP实现方式三"></a>7.4 AOP实现方式三</h3><p><code>使用注解方式实现</code></p><pre class="language-java" data-language="java"><code class="language-java">@Aspectpublic class Annolog &#123;    @Before(&quot;execution(* com.chengzzz.services.ServicesImpl.*(..))&quot;)    public void before()&#123;        System.out.println(&quot;注解前置增强&quot;);    &#125;&#125;</code></pre><pre class="language-none"><code class="language-none">&lt;!--注入注解切面类--&gt;&lt;bean id&#x3D;&quot;annolog&quot; class&#x3D;&quot;com.chengzzz.log.Annolog&quot;&#x2F;&gt;&lt;!--开启自动代理注解支持--&gt;&lt;!--JDK默认proxy-target-class&#x3D;&quot;false&quot;  若为true 则使用cglib实现   结果无任何区别--&gt;&lt;aop:aspectj-autoproxy proxy-target-class&#x3D;&quot;false&quot;&#x2F;&gt;</code></pre><p><code>tips  @Around时，方法中可有参数ProceedingJoinPoint 以此获取部分信息</code></p><pre class="language-java" data-language="java"><code class="language-java">@Around(&quot;execution(* com.chengzzz.services.ServicesImpl.*(..))&quot;)public void around(ProceedingJoinPoint joinPoint) throws Throwable&#123;    System.out.println(&quot;注解环绕前&quot;+joinPoint.getSignature());   Object proceed &#x3D; joinPoint.proceed();    System.out.println(&quot;注解环绕后&quot;+proceed);&#125;</code></pre><pre class="language-java" data-language="java"><code class="language-java">public class MyTest &#123;    public static void main(String[] args) &#123;      ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);        Services services &#x3D; context.getBean(&quot;services&quot;, Services.class);        services.query();    &#125;&#125;</code></pre><p><code>由于动态代理代理的是接口，所以getBean时，需要转换为接口</code></p><hr><h2 id="整合Mybatis"><a href="#整合Mybatis" class="headerlink" title="整合Mybatis"></a>整合Mybatis</h2><ol><li><p>导入jar包</p><ul><li>junit</li><li>mybatis</li><li>mysql</li><li>spring</li><li>aop</li><li>mybatis-spring</li></ul><p>&lt;!–hexoPostRenderEscape:<pre class="language-xml" data-language="xml"><code class="language-xml">&lt;dependencies&gt;<br> &lt;!-- https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;junit&#x2F;junit --&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;junit&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;junit&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;4.12&amp;lt;&amp;#x2F;version&amp;gt; &amp;lt;scope&amp;gt;test&amp;lt;&amp;#x2F;scope&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;<br> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java –&gt;<br> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;mysql&#x2F;mysql-connector-java –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;mysql&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;mysql-connector-java&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;8.0.21&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;</p><p> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;3.5.5&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;</p><p> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-webmvc –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.springframework&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-webmvc&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.7.RELEASE&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;<br> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.springframework&#x2F;spring-jdbc –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.springframework&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;spring-jdbc&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;5.2.7.RELEASE&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;<br> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.aspectj&#x2F;aspectjweaver –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.aspectj&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;aspectjweaver&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;1.9.5&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;</p><p> &lt;!– https:&#x2F;&#x2F;mvnrepository.com&#x2F;artifact&#x2F;org.mybatis&#x2F;mybatis-spring –&gt;<br> &lt;dependency&gt;</p><pre><code> &amp;lt;groupId&amp;gt;org.mybatis&amp;lt;&amp;#x2F;groupId&amp;gt; &amp;lt;artifactId&amp;gt;mybatis-spring&amp;lt;&amp;#x2F;artifactId&amp;gt; &amp;lt;version&amp;gt;2.0.5&amp;lt;&amp;#x2F;version&amp;gt;</code></pre><p> &lt;&#x2F;dependency&gt;</p></li></ol><p>&lt;&#x2F;dependencies&gt;</code></pre>:hexoPostRenderEscape–&gt;</p><ol start="2"><li>编写配置文件</li></ol><ol start="3"><li>测试</li></ol><h3 id="8-1-整合方式一"><a href="#8-1-整合方式一" class="headerlink" title="8.1 整合方式一"></a>8.1 整合方式一</h3><p>mybatis-config</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;    &lt;bean id&#x3D;&quot;dataSource&quot;          class&#x3D;&quot;org.springframework.jdbc.datasource.DriverManagerDataSource&quot;    &gt;        &lt;property name&#x3D;&quot;driverClassName&quot;                  value&#x3D;&quot;com.mysql.jdbc.Driver&quot; &#x2F;&gt;        &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis?useUnicode&#x3D;true&amp;characterEncoding&#x3D;utf8&amp;useSSL&#x3D;true&amp;serverTimezone&#x3D;UTC&quot; &#x2F;&gt;        &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;        &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;root&quot; &#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!-- 创建SqlSessionFactory MyBatis会话工厂对象 --&gt;    &lt;bean id&#x3D;&quot;sqlSessionFactory&quot;  class&#x3D;&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;&gt;        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot; &#x2F;&gt;        &lt;property name&#x3D;&quot;mapperLocations&quot; value&#x3D;&quot;classpath:com&#x2F;chengzzz&#x2F;mapper&#x2F;*.xml&quot;&#x2F;&gt;        &lt;property name&#x3D;&quot;typeAliasesPackage&quot; value&#x3D;&quot;com.chengzzz.pojo&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;bean id&#x3D;&quot;sqlSession&quot; class&#x3D;&quot;org.mybatis.spring.SqlSessionTemplate&quot; &gt;        &lt;constructor-arg index&#x3D;&quot;0&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><p>beans.xml</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;    &lt;import resource&#x3D;&quot;mybatis-config.xml&quot;&#x2F;&gt;   &lt;bean id&#x3D;&quot;userMapper&quot; class&#x3D;&quot;com.chengzzz.mapper.UserMapperImpl&quot;&gt;   &lt;property name&#x3D;&quot;sqlSession&quot; ref&#x3D;&quot;sqlSession&quot;&#x2F;&gt;   &lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt;</code></pre><p><code>Tips 注意 若未配置别名，mapper中返回类型需完整路径</code></p><p><code>实现过程</code></p><ol><li>编写数据源配置</li><li>sqlSessionFactory</li><li>sqlSessionTemplate</li><li>需要给接口加实现类</li><li>将实现类注入Spring</li><li>Test   </li></ol><hr><h3 id="8-2-整合方式二"><a href="#8-2-整合方式二" class="headerlink" title="8.2 整合方式二"></a>8.2 整合方式二</h3><p> 在usermapper的实现类中继承SqlSessionDaoSupport</p><p>通过spring的api来获取sqlTemplate</p><pre class="language-java" data-language="java"><code class="language-java">public class UserMapperImpl2 extends SqlSessionDaoSupport implements UserMapper&#123;    @Override    public List&lt;User&gt; selectList() &#123;        return getSqlSession().getMapper(UserMapper.class).selectList();    &#125;&#125;</code></pre><p>同时在spring中注册这个bean时</p><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;bean id&#x3D;&quot;userMapper2&quot; class&#x3D;&quot;com.chengzzz.mapper.UserMapperImpl2&quot;&gt;    &lt;property name&#x3D;&quot;sqlSessionFactory&quot; ref&#x3D;&quot;sqlSessionFactory&quot;&#x2F;&gt;&lt;&#x2F;bean&gt;</code></pre><p>将sqlSessionFactory注入即可省略sqlSessionTemplate的配置</p><hr><h2 id="声明式事务"><a href="#声明式事务" class="headerlink" title="声明式事务"></a>声明式事务</h2><h3 id="9-1-事务特点"><a href="#9-1-事务特点" class="headerlink" title="9.1 事务特点"></a>9.1 事务特点</h3><ul><li>将一组业务视为一个业务来实现，要么都成功，要么都失败</li><li>事务在项目开发中，十分重要，涉及到数据的一致性问题，不能马虎</li><li>确保完整性和一致性</li></ul><h3 id="9-2-事务的ACID原则"><a href="#9-2-事务的ACID原则" class="headerlink" title="9.2 事务的ACID原则"></a>9.2 事务的ACID原则</h3><ul><li><p>原子性 确保都失败或都成功。</p></li><li><p>一致性 确保资源状态统一。</p></li><li><p>隔离性</p><ul><li>多个业务操作同一个资源时，防止数据损坏。</li></ul></li><li><p>持久性</p><ul><li>事务一旦提交无论系统发生什么问题，结果都不会再被影响，被持久化地写到存储器中。</li></ul></li></ul><h3 id="9-3-声明式事务的使用"><a href="#9-3-声明式事务的使用" class="headerlink" title="9.3 声明式事务的使用"></a>9.3 声明式事务的使用</h3><ul><li>声明式事务：AOP的应用，非侵入式，横切</li></ul><pre class="language-xml" data-language="xml"><code class="language-xml">&lt;!--配置声明式事务--&gt;    &lt;bean id&#x3D;&quot;transactionManager&quot; class&#x3D;&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;        &lt;property name&#x3D;&quot;dataSource&quot; ref&#x3D;&quot;dataSource&quot;&#x2F;&gt;    &lt;&#x2F;bean&gt;    &lt;!--使用AOP实现事务的织入--&gt;    &lt;!--配置事务通知--&gt;    &lt;tx:advice id&#x3D;&quot;txAdvice&quot; transaction-manager&#x3D;&quot;transactionManager&quot;&gt;        &lt;!--给哪些方法配置事务--&gt;        &lt;!--事务的7种传播特性--&gt;        &lt;tx:attributes&gt;            &lt;tx:method name&#x3D;&quot;*&quot; propagation&#x3D;&quot;REQUIRED&quot;&#x2F;&gt;        &lt;&#x2F;tx:attributes&gt;    &lt;&#x2F;tx:advice&gt;    &lt;!--配置事务的切入--&gt;    &lt;aop:config&gt;        &lt;aop:pointcut id&#x3D;&quot;point&quot; expression&#x3D;&quot;execution(* com.chengzzz.mapper.*.*(..))&quot;&#x2F;&gt;        &lt;aop:advisor advice-ref&#x3D;&quot;txAdvice&quot; pointcut-ref&#x3D;&quot;point&quot;&#x2F;&gt;    &lt;&#x2F;aop:config&gt;</code></pre><ul><li>编程式事务：需要在代码中，进行事务的管理</li></ul><p><code>Tips</code></p><p>为什么需要事务？</p><ul><li>如果不配置事务，可能存在数据提交不一致的情况</li><li>如果我们不在Spring中去配置声明式事务，就需要在代码中手动配置事务</li><li>事务在项目的开发中，十分重要涉及到数据的一致性和完整性问题，不容马虎</li></ul><hr><hr><hr><hr>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring boot 踩坑记录</title>
      <link href="/2020/08/18/Spring%20boot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
      <url>/2020/08/18/Spring%20boot%20%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-tUQHrjqQ" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h1 id="Spring-boot-踩坑记录"><a href="#Spring-boot-踩坑记录" class="headerlink" title="Spring boot 踩坑记录"></a>Spring boot 踩坑记录</h1><h2 id="打包"><a href="#打包" class="headerlink" title="打包"></a>打包</h2><p>[TOC]</p><h3 id="Tests-run-1-Failures-0-Errors-1-Skipped-0-Time-elapsed-2-432-s-lt-lt-lt-FAILURE-in-com-ems-web-WebApplicationTests"><a href="#Tests-run-1-Failures-0-Errors-1-Skipped-0-Time-elapsed-2-432-s-lt-lt-lt-FAILURE-in-com-ems-web-WebApplicationTests" class="headerlink" title="Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 2.432 s &lt;&lt;&lt; FAILURE! - in com.ems.web.WebApplicationTests"></a>Tests run: 1, Failures: 0, Errors: 1, Skipped: 0, Time elapsed: 2.432 s &lt;&lt;&lt; FAILURE! - in com.ems.web.WebApplicationTests</h3><p>解决方案</p><p>在pom.xml中添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs plain">&lt;plugin&gt;<br>    &lt;groupId&gt;org.apache.maven.plugins&lt;&#x2F;groupId&gt;<br>    &lt;artifactId&gt;maven-surefire-plugin&lt;&#x2F;artifactId&gt;<br>    &lt;configuration&gt;<br>     &lt;skip&gt;true&lt;&#x2F;skip&gt;<br>    &lt;&#x2F;configuration&gt;<br>   &lt;&#x2F;plugin&gt;<br></code></pre></td></tr></table></figure><p>————————————————<br>版权声明：本文为CSDN博主「漫跑的小乌龟」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。<br>原文链接：<a href="https://blog.csdn.net/HHHbetter123/java/article/details/78561642">https://blog.csdn.net/HHHbetter123/java/article/details/78561642</a></p><hr><h3 id="打包后target目录找不到"><a href="#打包后target目录找不到" class="headerlink" title="打包后target目录找不到"></a>打包后target目录找不到</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822170335.png"></p><hr><h3 id="Failed-to-execute-goal-org-apache-maven-plugins-maven-install-plugin-2-5-2-install-default"><a href="#Failed-to-execute-goal-org-apache-maven-plugins-maven-install-plugin-2-5-2-install-default" class="headerlink" title="Failed to execute goal org.apache.maven.plugins:maven-install-plugin:2.5.2:install (default-"></a>Failed to execute goal org.apache.maven.plugins:maven-install-plugin:2.5.2:install (default-</h3><p>[ERROR] Failed to execute goal org.apache.maven.plugins:maven-install-plugin:2.5.2:install (default-install) on project commons-base: Failed to install artifact <a href="http://com.xxx/">com.xxx</a>:commons-base:jar:</p><p>使用Lifecycle下的 install打包即可</p><hr><h2 id="Mybatis-plus"><a href="#Mybatis-plus" class="headerlink" title="Mybatis-plus"></a>Mybatis-plus</h2><h3 id="Could-not-set-property-‘id’-of-‘class-com-xxx-xxx-xx-PO’-with-value-‘1312434545453’"><a href="#Could-not-set-property-‘id’-of-‘class-com-xxx-xxx-xx-PO’-with-value-‘1312434545453’" class="headerlink" title="Could not set property ‘id’ of ‘class com.xxx.xxx.xx.PO’ with value ‘1312434545453’"></a>Could not set property ‘id’ of ‘class com.xxx.xxx.xx.PO’ with value ‘1312434545453’</h3><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200822161514.png"></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Boot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安卓蚂蚁森林能量脚本</title>
      <link href="/2020/08/18/%E5%AE%89%E5%8D%93%E8%9A%82%E8%9A%81%E6%A3%AE%E6%9E%97%E8%83%BD%E9%87%8F%E8%84%9A%E6%9C%AC-%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%A8%A1%E5%BC%8F/"/>
      <url>/2020/08/18/%E5%AE%89%E5%8D%93%E8%9A%82%E8%9A%81%E6%A3%AE%E6%9E%97%E8%83%BD%E9%87%8F%E8%84%9A%E6%9C%AC-%E6%97%A0%E9%9A%9C%E7%A2%8D%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[    <div id="aplayer-KvjcmYLl" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><p><a href="https://github.com/YYYet/ant-forest-easyclick">开源地址</a></p><h1 id="安卓蚂蚁森林能量脚本-无障碍模式"><a href="#安卓蚂蚁森林能量脚本-无障碍模式" class="headerlink" title="安卓蚂蚁森林能量脚本-无障碍模式"></a>安卓蚂蚁森林能量脚本-无障碍模式</h1><h4 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h4><ul><li><input checked="" disabled="" type="checkbox"> 收自己+偷列表 </li><li><input checked="" disabled="" type="checkbox"> 收别人浇给自己的水</li><li><input checked="" disabled="" type="checkbox"> 帮列表收能量</li></ul><h4 id="模式"><a href="#模式" class="headerlink" title="模式"></a>模式</h4><ul><li><input checked="" disabled="" type="checkbox"> 定时模式 (手动定时启动脚本)</li><li><input checked="" disabled="" type="checkbox"> 挂机模式 (循环挂机运行脚本)</li><li><input disabled="" type="checkbox"> 自动模式 (自动检测好友能量成熟剩余时间并定时运行脚本)</li></ul><blockquote><p> 以上为已完成的功能</p></blockquote><hr><h4 id="使用说明"><a href="#使用说明" class="headerlink" title="使用说明"></a>使用说明</h4><p>安装软件并给予申请的三个权限</p><p>下拉通知栏观察无障碍模式是否启动</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145614.png"></p><p>如图未启动则打开使用权限页面，点击启动环境</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145630.png"></p><p>悬浮窗权限自行选择是否打开，打开之后重启软件，将会显示日志窗口</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145653.png"></p><p>点击参数设置</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145709.png"></p><p>选择模式</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145721.png"></p><p>选择模式后点击保存参数，再点击启动脚本即可</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145729.png"></p><blockquote><p>注意</p><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/20200818145742.png"></p><p>定时模式下，填写时间后选择开启定时</p><p>脚本如果长期运行，建议开启屏幕常亮</p></blockquote><hr><h4 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h4><ul><li><p>点击启动环境后无反应或者卡住</p><p>直接清除后台后重新运行软件点击启动环境</p></li><li><p>我开启了无障碍却仍然提示我打开无障碍</p><p>直接清除后台后重新运行软件，然后重新点击启动环境，若没有解决可重启设备</p></li><li><p>脚本部分功能无效</p><p>直接清除后台后重新运行软件点击启动环境</p></li><li><p>无法识别能量罩</p><p>将日志窗口关闭或者拖动到左下角</p></li></ul><hr><h4 id="计划功能"><a href="#计划功能" class="headerlink" title="计划功能"></a>计划功能</h4><ul><li><input disabled="" type="checkbox"> 加入刷步攒能量</li><li><input disabled="" type="checkbox"> 加入批量浇水</li><li><input disabled="" type="checkbox"> 加入运行统计</li><li><input disabled="" type="checkbox"> 加入自动模式</li><li><input disabled="" type="checkbox"> 加入屏幕唤醒及解锁</li></ul><p>​      </p><hr><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>脚本采用EasyClick编写，由于刚接触所以代码质量不高，此项目旨在学习和提高安卓脚本水平</p><p>另外发现github上大佬 SuperMonster003 也在论坛 </p><p>他的帖子<a href="https://www.52pojie.cn/thread-1117218-1-1.html">https://www.52pojie.cn/thread-1117218-1-1.html</a> </p><p>他的主页<a href="https://github.com/SuperMonster003">https://github.com/SuperMonster003</a></p><hr><h4 id="下载链接"><a href="#下载链接" class="headerlink" title="下载链接"></a>下载链接</h4><p><a href="https://lanzous.com/b0cq9z3ef">https://lanzous.com/b0cq9z3ef</a>  密码:7nh2</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐心健康修改wx zfb qq步数</title>
      <link href="/2020/08/17/%E4%B9%90%E5%BF%83%E5%81%A5%E5%BA%B7/"/>
      <url>/2020/08/17/%E4%B9%90%E5%BF%83%E5%81%A5%E5%BA%B7/</url>
      
        <content type="html"><![CDATA[<h2 id="乐心健康"><a href="#乐心健康" class="headerlink" title="乐心健康"></a>乐心健康</h2>    <div id="aplayer-szQrrIix" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h1 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h1><p>此程序不调用任何第三方接口，不参与任何非法项目，仅供网络编程学习以及参考。</p><p>自动步数提交已经完成，由于需要上传乐心账号和设备信息等相关信息，乐心账号即为手机号，论坛判为隐私，这里上传无自动提交版本。即不上传任何信息到个人服务器（除了提交相关信息到乐心官方）</p><p><a href="https://github.com/YYYet/Cz-">开源地址</a></p><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>下载乐某健康APP:</p><p>1.从应用商店或者浏览器下载某心健康App，打开软件并选择手机号登录</p><p><img src= "/img/loading.gif" data-lazy-src="https://txc.gtimg.com/data/130280/2020/0320/1fd9360ff94b7e606fb6607cd5739092.jpeg" alt="1fd9360ff94b7e606fb6607cd5739092.jpeg"></p><p>2.登录之后，点击我的-&gt;设置-&gt;账号与安全-&gt;设置密码(修改密码)，设置你自己记得住的密码</p><p><img src= "/img/loading.gif" data-lazy-src="https://txc.gtimg.com/data/140335/2020/0502/a1c13cfe0dfbf3863cad2838ebfa3009.jpeg" alt="a1c13cfe0dfbf3863cad2838ebfa3009.jpeg"></p><p>3.回到App首页，点击我的-&gt;数据共享，绑定你想同步数据的项目</p><p>注：同步微信运动请按照要求关注【<strong>乐心运动</strong>】公众号。</p><p><img src= "/img/loading.gif" data-lazy-src="https://txc.gtimg.com/data/140335/2020/0507/7bb37ab660a893db887bdddf203122eb.jpeg" alt="7bb37ab660a893db887bdddf203122eb.jpeg"></p><p>4.回到Cz步数助手，依次输入乐心账号（注册乐心的手机号），字母验证码，短信验证码，需要刷的步数，然后点击提交，少数情况需要滑动拼图验证码进行验证。然后步数即可自动同步至你绑定的所有平台。</p><p><img src= "/img/loading.gif" data-lazy-src="https://txc.gtimg.com/data/95845/2020/0612/bbfeeeab7ba95dfabd4bae6e667f4001.jpeg" alt="bbfeeeab7ba95dfabd4bae6e667f4001.jpeg"></p><h2 id="会持续更新吗"><a href="#会持续更新吗" class="headerlink" title="会持续更新吗"></a>会持续更新吗</h2><ol><li><p>我会在空闲时间关注Cz步数助手的走向</p></li><li><p>如果产生不良影响我将第一时间对软件进行处理</p></li></ol><h2 id="软件相关问题"><a href="#软件相关问题" class="headerlink" title="软件相关问题"></a>软件相关问题</h2><h3 id="为什么我的步数不能同步"><a href="#为什么我的步数不能同步" class="headerlink" title="为什么我的步数不能同步"></a>为什么我的步数不能同步</h3><ol><li>成功提交，即乐心健康中有显示，却未同步至wx qq zfb 请参考上方使用说明，自行测试。如果还是同步不了，大可放弃使用，软件免费，我也没有什么精力做售后</li><li>如果提示未知，那么在cookie页面。长按删除，再重新返回主页面登录一次即可</li><li>登录时提示短信验证码已达上限，那么今天就无法使用验证码登录了，这个是官方的限制。第二天即可恢复</li></ol><h3 id="软件时常崩溃"><a href="#软件时常崩溃" class="headerlink" title="软件时常崩溃"></a>软件时常崩溃</h3><ol><li><p>应用基于安卓4.4开发，低于4.4无法使用</p></li><li><p>52pj为唯一发布平台，现移植到个人博客。如果遇到了非版本崩溃问题，请评论回复  在什么情况下遇到的问题+问题出现频率 </p></li></ol><h3 id="IOS可以使用吗"><a href="#IOS可以使用吗" class="headerlink" title="IOS可以使用吗"></a>IOS可以使用吗</h3><ol><li>目前只支持android并未支持ios</li></ol><h3 id="支持哪些应用改步数"><a href="#支持哪些应用改步数" class="headerlink" title="支持哪些应用改步数"></a>支持哪些应用改步数</h3><ol><li><p>支付宝</p></li><li><p>微信</p></li><li><p>QQ</p></li></ol><h3 id="需要root吗"><a href="#需要root吗" class="headerlink" title="需要root吗"></a>需要root吗</h3><p>不需要</p><h3 id="收费吗"><a href="#收费吗" class="headerlink" title="收费吗"></a>收费吗</h3><p>免费</p><h3 id="最高支持多少"><a href="#最高支持多少" class="headerlink" title="最高支持多少"></a>最高支持多少</h3><p>最高10W步  未具体测试</p><h3 id="相关说明"><a href="#相关说明" class="headerlink" title="相关说明"></a>相关说明</h3><p>第一次请使用手机号登录 然后修改，手机号每天只允许发送三次验证码（官方限制）且用且珍惜</p><p>使用手机号登录修改过之后，可以使用首页底部的使用cookie修改  不需要手机号登录即可  直到失效后 再次手机号登录一次就可以</p><h1 id="应用说明"><a href="#应用说明" class="headerlink" title="应用说明"></a>应用说明</h1><p>注册过账号之后，打开Cz步数助手进行账号登录</p><p>输入图片验证码以及短信验证码后 提示保存成功 </p><p>返回首页，使用cookie进行修改步数，以此避免每日短信3次上限</p><p>若cookie失效，请手动删除后再次短信登录，否则会提示保存失败</p><h2 id="运行截图"><a href="#运行截图" class="headerlink" title="运行截图"></a>运行截图</h2><p><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/FABBB34A30DEB0D6FC396992E172E7E5.jpg" style="zoom:25%;" /><img src= "/img/loading.gif" data-lazy-src="https://testchengzzz.oss-cn-shanghai.aliyuncs.com/img/78D58C3360A125EE9BFD0428F62FF824.jpg" style="zoom: 25%;" /></p><h1 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h1><p>蓝奏云 <a href="https://chengzzz.lanzous.com/b0cqeofyb">https://chengzzz.lanzous.com/b0cqeofyb</a><br>密码:b42o</p><p>2020 8 12更新版本支持密码登录</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 抓包 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo的安装使用</title>
      <link href="/2020/08/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2020/08/16/hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<h2 id="hexo-matery"><a href="#hexo-matery" class="headerlink" title="hexo+matery"></a>hexo+matery</h2>    <div id="aplayer-fubUhDae" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="5186066572" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#ad7a86"    ></div><h3 id="首先安装nodejs，官网一键安装即可"><a href="#首先安装nodejs，官网一键安装即可" class="headerlink" title="首先安装nodejs，官网一键安装即可"></a>首先安装nodejs，官网一键安装即可</h3><h3 id="新建一个目录，并安装hexo"><a href="#新建一个目录，并安装hexo" class="headerlink" title="新建一个目录，并安装hexo"></a>新建一个目录，并安装hexo</h3><pre class="language-bash" data-language="bash"><code class="language-bash">$  npm install -g hexo-cli</code></pre><h3 id="安装完成之后，使用hexo进行模板生成"><a href="#安装完成之后，使用hexo进行模板生成" class="headerlink" title="安装完成之后，使用hexo进行模板生成"></a>安装完成之后，使用hexo进行模板生成</h3><pre class="language-bash" data-language="bash"><code class="language-bash">Yet@DESKTOP-9S7FNJU MINGW64 &#x2F;g&#x2F;github&#x2F;blog$ hexo init</code></pre><h3 id="如果找不到hexo-那么将G-nodejs-node-global-node-modules-hexo-cli-bin-加入path-即-搜索hexo将bin加入环境变量"><a href="#如果找不到hexo-那么将G-nodejs-node-global-node-modules-hexo-cli-bin-加入path-即-搜索hexo将bin加入环境变量" class="headerlink" title="如果找不到hexo 那么将G:\nodejs\node_global\node_modules\hexo-cli\bin  加入path 即 搜索hexo将bin加入环境变量"></a>如果找不到hexo 那么将G:\nodejs\node_global\node_modules\hexo-cli\bin  加入path 即 搜索hexo将bin加入环境变量</h3><h3 id="如果提示：-hexo-server-Usage-hexo-，是因为hexo-3以后的版本需要手动安装server模块，执行下面的命令：npm-install-hexo-server-–save"><a href="#如果提示：-hexo-server-Usage-hexo-，是因为hexo-3以后的版本需要手动安装server模块，执行下面的命令：npm-install-hexo-server-–save" class="headerlink" title="如果提示： hexo server Usage: hexo ，是因为hexo 3以后的版本需要手动安装server模块，执行下面的命令：npm install hexo-server –save"></a>如果提示： hexo server Usage: hexo <command>，是因为hexo 3以后的版本需要手动安装server模块，执行下面的命令：npm install hexo-server –save</h3><pre class="language-bash" data-language="bash"><code class="language-bash">Yet@DESKTOP-9S7FNJU MINGW64 &#x2F;g&#x2F;github&#x2F;blog$ npm install hexo-server --save</code></pre><h3 id="如果提示"><a href="#如果提示" class="headerlink" title="如果提示"></a>如果提示</h3><p>ERROR Deployer not found: git</p><h3 id="那么输入以下命令即可"><a href="#那么输入以下命令即可" class="headerlink" title="那么输入以下命令即可"></a>那么输入以下命令即可</h3><pre class="language-bash" data-language="bash"><code class="language-bash">npm install &#96;--&#96;save hexo-deployer-git</code></pre><h3 id="返回目录，修改-config-yml中的deploy"><a href="#返回目录，修改-config-yml中的deploy" class="headerlink" title="返回目录，修改_config.yml中的deploy"></a>返回目录，修改_config.yml中的deploy</h3><pre class="language-yml" data-language="yml"><code class="language-yml">deploy:  type: git  repo: https:&#x2F;&#x2F;github.com&#x2F;YYYet&#x2F;YYYet.github.io.git  branch: master</code></pre><h3 id="进行提交-g为生成静态页面-d为上传"><a href="#进行提交-g为生成静态页面-d为上传" class="headerlink" title="进行提交 g为生成静态页面 -d为上传"></a>进行提交 g为生成静态页面 -d为上传</h3><pre class="language-bash" data-language="bash"><code class="language-bash">Yet@DESKTOP-9S7FNJU MINGW64 &#x2F;g&#x2F;github&#x2F;blog$ hexo g -d</code></pre><p>此命令为开启本地调试 <a href="http://localhost:4000/">http://localhost:4000/</a></p><pre class="language-bash" data-language="bash"><code class="language-bash">Yet@DESKTOP-9S7FNJU MINGW64 &#x2F;g&#x2F;github&#x2F;blog$ hexo s</code></pre><h3 id="访问YYYet-github-io-git即可"><a href="#访问YYYet-github-io-git即可" class="headerlink" title="访问YYYet.github.io.git即可"></a>访问YYYet.github.io.git即可</h3>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
